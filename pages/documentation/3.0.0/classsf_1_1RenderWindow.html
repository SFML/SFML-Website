<!DOCTYPE html>
<html lang="en" class="no-js">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <meta name="description" content="Simple and Fast Multimedia Library" />
        <link rel="canonical" href="https://www.sfml-dev.org/documentation/3.0.0/" />
        <link rel="icon" href="../../images/favicon.ico" />
        <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.44" />
        <title>Documentation for SFML 3.0.0 - Simple and Fast Multimedia Library</title>
        <link rel="stylesheet" href="../../assets/stylesheets/main.6f8fc17f.min.css" />
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback" />
        <style>
            :root {
                --md-text-font: "Ubuntu";
                --md-code-font: "Roboto Mono";
            }
        </style>
        <link rel="stylesheet" href="../../styles/extra.css" />
        <script>
            (__md_scope = new URL("../..", location)),
                (__md_hash = (e) => [...e].reduce((e, _) => (e << 5) - e + _.charCodeAt(0), 0)),
                (__md_get = (e, _ = localStorage, t = __md_scope) => JSON.parse(_.getItem(t.pathname + "." + e))),
                (__md_set = (e, _, t = localStorage, a = __md_scope) => {
                    try {
                        t.setItem(a.pathname + "." + e, JSON.stringify(_));
                    } catch (e) {}
                });
        </script>
        <!-- Doxygen Overrides -->
        <link rel="stylesheet" type="text/css" href="doxystyle.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <script type="text/javascript" src="resize.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
            /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
            $(document).ready(function () {
                init_search();
            });
            /* @license-end */
        </script>
        <!-- Doxygen Overrides -->
    </head>
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
        <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off" />
        <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off" />
        <label class="md-overlay" for="__drawer"></label>
        <div data-md-component="announce"></div>
        <header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
            <nav class="md-header__inner md-grid" aria-label="Header">
                <a href="../.." title="Simple and Fast Multimedia Library" class="md-header__button md-logo" aria-label="Simple and Fast Multimedia Library" data-md-component="logo">
                    <img src="../../images/logo.png" alt="logo" />
                </a>
                <label class="md-header__button md-icon" for="__drawer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z" /></svg>
                </label>
                <div class="md-header__title" data-md-component="header-title">
                    <div class="md-header__ellipsis">
                        <div class="md-header__topic">
                            <span class="md-ellipsis"> Simple and Fast Multimedia Library </span>
                        </div>
                        <div class="md-header__topic" data-md-component="header-topic">
                            <span class="md-ellipsis"> Documentation for SFML 3.0.0 </span>
                        </div>
                    </div>
                </div>
                <label class="md-header__button md-icon" for="__search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5" />
                    </svg>
                </label>
                <div class="md-search" data-md-component="search" role="dialog">
                    <label class="md-search__overlay" for="__search"></label>
                    <div class="md-search__inner" role="search">
                        <form class="md-search__form" name="search">
                            <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required />
                            <label class="md-search__icon md-icon" for="__search">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                    <path
                                        d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"
                                    />
                                </svg>
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z" /></svg>
                            </label>
                            <nav class="md-search__options" aria-label="Search">
                                <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /></svg>
                                </button>
                            </nav>
                            <div class="md-search__suggest" data-md-component="search-suggest"></div>
                        </form>
                        <div class="md-search__output">
                            <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
                                <div class="md-search-result" data-md-component="search-result">
                                    <div class="md-search-result__meta">Initializing search</div>
                                    <ol class="md-search-result__list" role="presentation"></ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="md-header__source">
                    <a href="https://github.com/SFML/SFML" title="Go to repository" class="md-source" data-md-component="source">
                        <div class="md-source__icon md-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
                                <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                <path
                                    d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"
                                />
                            </svg>
                        </div>
                        <div class="md-source__repository">SFML</div>
                    </a>
                </div>
            </nav>
            <nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
                <div class="md-grid">
                    <ul class="md-tabs__list">
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/" class="md-tabs__link"> Home </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/learn/" class="md-tabs__link"> Learn </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/tutorials/" class="md-tabs__link"> Tutorials </a>
                        </li>
                        <li class="md-tabs__item md-tabs__item--active">
                            <a href="https://www.sfml-dev.org/documentation/" class="md-tabs__link"> Documentation </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/download/" class="md-tabs__link"> Download </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/community/" class="md-tabs__link"> Community </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="https://www.sfml-dev.org/development/" class="md-tabs__link"> Development </a>
                        </li>
                    </ul>
                </div>
            </nav>
        </header>
        <div class="md-container" data-md-component="container">
            <main class="md-main" data-md-component="main">
                <div class="md-main__inner md-grid">
                    <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
                        <div class="md-sidebar__scrollwrap" style="height: 832px">
                            <div class="md-sidebar__inner">
                                <nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
                                    <label class="md-nav__title" for="__drawer">
                                        <a href="../.." title="Simple and Fast Multimedia Library" class="md-nav__button md-logo" aria-label="Simple and Fast Multimedia Library" data-md-component="logo">
                                            <img src="../../images/logo.png" alt="logo" />
                                        </a>
                                        Simple and Fast Multimedia Library
                                    </label>
                                    <div class="md-nav__source">
                                        <a href="https://github.com/SFML/SFML" title="Go to repository" class="md-source" data-md-component="source">
                                            <div class="md-source__icon md-icon">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
                                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                                    <path
                                                        d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"
                                                    ></path>
                                                </svg>
                                            </div>
                                            <div class="md-source__repository md-source__repository--active">
                                            </div>
                                        </a>
                                    </div>
                                    <ul class="md-nav__list">
                                        <li class="md-nav__item">
                                            <a href="https://www.sfml-dev.org/" class="md-nav__link">
                                                <span class="md-ellipsis"> Home </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="https://www.sfml-dev.org/learn/" class="md-nav__link">
                                                <span class="md-ellipsis"> Learn </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
                                            <a href="https://www.sfml-dev.org/tutorials/" class="md-nav__link">
                                                <span class="md-ellipsis"> Tutorials </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
                                            <input class="md-nav__toggle md-toggle" type="checkbox" id="__nav_4" checked="" />
                                            <div class="md-nav__link md-nav__container">
                                                <a href="./" class="md-nav__link md-nav__link--active">
                                                    <span class="md-ellipsis"> Documentation </span>
                                                </a>
                                                <label class="md-nav__link md-nav__link--active" for="__nav_4" id="__nav_4_label" tabindex="">
                                                    <span class="md-nav__icon md-icon"></span>
                                                </label>
                                            </div>
                                            <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
                                                <label class="md-nav__title" for="__nav_4">
                                                    <span class="md-nav__icon md-icon"></span>
                                                    Documentation
                                                </label>
                                                <ul class="md-nav__list">
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/3.0.0/" class="md-nav__link md-nav__link--active">
                                                            <span class="md-ellipsis"> SFML 3.0.0 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.6.2/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.6.2 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.6.1/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.6.1 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.6.0/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.6.0 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.5.1/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.5.1 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.5.0/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.5.0 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.4.2/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.4.2 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.4.1/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.4.1 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.4.0/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.4.0 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.3.2/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.3.2 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.3.1/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.3.1 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.3/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.3 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.2/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.2 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.1/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.1 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/2.0/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 2.0 </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="https://www.sfml-dev.org/documentation/1.6/" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML 1.6 </span>
                                                        </a>
                                                    </li>
                                                </ul>
                                            </nav>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="https://www.sfml-dev.org/download/" class="md-nav__link">
                                                <span class="md-ellipsis"> Download </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="https://www.sfml-dev.org/community/" class="md-nav__link">
                                                <span class="md-ellipsis"> Community </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="https://www.sfml-dev.org/development/" class="md-nav__link">
                                                <span class="md-ellipsis"> Development </span>
                                            </a>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </div>
                    <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" style="top: 158px">
                        <div class="md-sidebar__scrollwrap" style="height: 832px">
                            <div class="md-sidebar__inner">
                                <nav class="md-nav md-nav--secondary" aria-label="Table of contents"></nav>
                            </div>
                        </div>
                    </div>
                    <div class="md-content contents">
                        <div><!-- top -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1RenderWindow.html">RenderWindow</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsf_1_1RenderWindow-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::RenderWindow Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> that can serve as a target for 2D drawing.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RenderWindow_8hpp_source.html">SFML/Graphics/RenderWindow.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderWindow:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1RenderWindow.png" usemap="#sf::RenderWindow_map" alt=""/>
  <map id="sf::RenderWindow_map" name="sf::RenderWindow_map">
<area href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering." alt="sf::Window" shape="rect" coords="61,56,174,80"/>
<area href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)" alt="sf::RenderTarget" shape="rect" coords="184,56,297,80"/>
<area href="classsf_1_1WindowBase.html" title="Window that serves as a base for other windows." alt="sf::WindowBase" shape="rect" coords="0,0,113,24"/>
<area href="classsf_1_1GlResource.html" title="Base class for classes that require an OpenGL context." alt="sf::GlResource" shape="rect" coords="123,0,236,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add082448ad1384c0bd475a70cf4f7df1" id="r_add082448ad1384c0bd475a70cf4f7df1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add082448ad1384c0bd475a70cf4f7df1">RenderWindow</a> ()=default</td></tr>
<tr class="memdesc:add082448ad1384c0bd475a70cf4f7df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:add082448ad1384c0bd475a70cf4f7df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417c0ea193537b0104b6f6c52e9d7163" id="r_a417c0ea193537b0104b6f6c52e9d7163"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417c0ea193537b0104b6f6c52e9d7163">RenderWindow</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, std::uint32_t style=<a class="el" href="group__window.html#gga5e7da6549090361249790ccb464158cca5597cd420fc461807e4a201c92adea37">Style::Default</a>, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state=<a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a>, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings={})</td></tr>
<tr class="memdesc:a417c0ea193537b0104b6f6c52e9d7163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new window.  <br /></td></tr>
<tr class="separator:a417c0ea193537b0104b6f6c52e9d7163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af405d17c1e5e042886afff04b3a77f97" id="r_af405d17c1e5e042886afff04b3a77f97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af405d17c1e5e042886afff04b3a77f97">RenderWindow</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings={})</td></tr>
<tr class="memdesc:af405d17c1e5e042886afff04b3a77f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new window.  <br /></td></tr>
<tr class="separator:af405d17c1e5e042886afff04b3a77f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19debea720c5cb4b7c19886f464ae1c7" id="r_a19debea720c5cb4b7c19886f464ae1c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19debea720c5cb4b7c19886f464ae1c7">RenderWindow</a> (<a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> handle, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings={})</td></tr>
<tr class="memdesc:a19debea720c5cb4b7c19886f464ae1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the window from an existing control.  <br /></td></tr>
<tr class="separator:a19debea720c5cb4b7c19886f464ae1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d9a6263e05fd4ed4b31a5c202cc642" id="r_af5d9a6263e05fd4ed4b31a5c202cc642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d9a6263e05fd4ed4b31a5c202cc642">getSize</a> () const override</td></tr>
<tr class="memdesc:af5d9a6263e05fd4ed4b31a5c202cc642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the rendering region of the window.  <br /></td></tr>
<tr class="separator:af5d9a6263e05fd4ed4b31a5c202cc642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4d2434d6c2d058485d8a35b10afb25" id="r_aba4d2434d6c2d058485d8a35b10afb25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba4d2434d6c2d058485d8a35b10afb25">setIcon</a> (const <a class="el" href="classsf_1_1Image.html">Image</a> &amp;icon)</td></tr>
<tr class="memdesc:aba4d2434d6c2d058485d8a35b10afb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the window's icon.  <br /></td></tr>
<tr class="separator:aba4d2434d6c2d058485d8a35b10afb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e57e5284d9abf1095171d157dd27b3f" id="r_a1e57e5284d9abf1095171d157dd27b3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e57e5284d9abf1095171d157dd27b3f">isSrgb</a> () const override</td></tr>
<tr class="memdesc:a1e57e5284d9abf1095171d157dd27b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the window will use sRGB encoding when drawing on it.  <br /></td></tr>
<tr class="separator:a1e57e5284d9abf1095171d157dd27b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5476821139d5a7f0e4df19dab69b56" id="r_a3f5476821139d5a7f0e4df19dab69b56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f5476821139d5a7f0e4df19dab69b56">setActive</a> (bool active=true) override</td></tr>
<tr class="memdesc:a3f5476821139d5a7f0e4df19dab69b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the window as the current target for OpenGL rendering.  <br /></td></tr>
<tr class="separator:a3f5476821139d5a7f0e4df19dab69b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f112046c240b477963326e2363e18" id="r_ae77f112046c240b477963326e2363e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#ae77f112046c240b477963326e2363e18">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, std::uint32_t style=<a class="el" href="group__window.html#gga5e7da6549090361249790ccb464158cca5597cd420fc461807e4a201c92adea37">Style::Default</a>, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state=<a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a>) override</td></tr>
<tr class="memdesc:ae77f112046c240b477963326e2363e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:ae77f112046c240b477963326e2363e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10c7fc5904ddff72a0fede61758679" id="r_ace10c7fc5904ddff72a0fede61758679"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#ace10c7fc5904ddff72a0fede61758679">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, std::uint32_t style, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:ace10c7fc5904ddff72a0fede61758679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:ace10c7fc5904ddff72a0fede61758679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17af5e75b858635f45ad46ce91668ce8" id="r_a17af5e75b858635f45ad46ce91668ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a17af5e75b858635f45ad46ce91668ce8">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state) override</td></tr>
<tr class="memdesc:a17af5e75b858635f45ad46ce91668ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:a17af5e75b858635f45ad46ce91668ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3667f889b2b288c13fe8f039cbad9931" id="r_a3667f889b2b288c13fe8f039cbad9931"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a3667f889b2b288c13fe8f039cbad9931">create</a> (<a class="el" href="classsf_1_1VideoMode.html">VideoMode</a> mode, const <a class="el" href="classsf_1_1String.html">String</a> &amp;title, <a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a> state, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:a3667f889b2b288c13fe8f039cbad9931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window.  <br /></td></tr>
<tr class="separator:a3667f889b2b288c13fe8f039cbad9931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246d47ddea8ad787be150e09df1fc53" id="r_a5246d47ddea8ad787be150e09df1fc53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a5246d47ddea8ad787be150e09df1fc53">create</a> (<a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> handle) override</td></tr>
<tr class="memdesc:a5246d47ddea8ad787be150e09df1fc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window from an existing control.  <br /></td></tr>
<tr class="separator:a5246d47ddea8ad787be150e09df1fc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064dd5dd7bb337fb9f5635f580081a1e" id="r_a064dd5dd7bb337fb9f5635f580081a1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a064dd5dd7bb337fb9f5635f580081a1e">create</a> (<a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> handle, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:a064dd5dd7bb337fb9f5635f580081a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create (or recreate) the window from an existing control.  <br /></td></tr>
<tr class="separator:a064dd5dd7bb337fb9f5635f580081a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d808a3682db8d113d67354bcbd717d" id="r_ab1d808a3682db8d113d67354bcbd717d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#ab1d808a3682db8d113d67354bcbd717d">close</a> () override</td></tr>
<tr class="memdesc:ab1d808a3682db8d113d67354bcbd717d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the window and destroy all the attached resources.  <br /></td></tr>
<tr class="separator:ab1d808a3682db8d113d67354bcbd717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0605afbaceb02b098f9d731b7ab4203d" id="r_a0605afbaceb02b098f9d731b7ab4203d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a0605afbaceb02b098f9d731b7ab4203d">getSettings</a> () const</td></tr>
<tr class="memdesc:a0605afbaceb02b098f9d731b7ab4203d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the settings of the OpenGL context of the window.  <br /></td></tr>
<tr class="separator:a0605afbaceb02b098f9d731b7ab4203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59041c4556e0351048f8aff366034f61" id="r_a59041c4556e0351048f8aff366034f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#a59041c4556e0351048f8aff366034f61">setVerticalSyncEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a59041c4556e0351048f8aff366034f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable vertical synchronization.  <br /></td></tr>
<tr class="separator:a59041c4556e0351048f8aff366034f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4322d315baf93405bf0d5087ad5e784" id="r_af4322d315baf93405bf0d5087ad5e784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#af4322d315baf93405bf0d5087ad5e784">setFramerateLimit</a> (unsigned int limit)</td></tr>
<tr class="memdesc:af4322d315baf93405bf0d5087ad5e784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit the framerate to a maximum fixed frequency.  <br /></td></tr>
<tr class="separator:af4322d315baf93405bf0d5087ad5e784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab549da64cedf74fa6f1ae7a3cc79e0" id="r_aaab549da64cedf74fa6f1ae7a3cc79e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#aaab549da64cedf74fa6f1ae7a3cc79e0">setActive</a> (bool active=true) const</td></tr>
<tr class="memdesc:aaab549da64cedf74fa6f1ae7a3cc79e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the window as the current target for OpenGL rendering.  <br /></td></tr>
<tr class="separator:aaab549da64cedf74fa6f1ae7a3cc79e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabf839cb103ac96cfc82f781638772a" id="r_adabf839cb103ac96cfc82f781638772a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a">display</a> ()</td></tr>
<tr class="memdesc:adabf839cb103ac96cfc82f781638772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display on screen what has been rendered to the window so far.  <br /></td></tr>
<tr class="separator:adabf839cb103ac96cfc82f781638772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43559822564ef958dc664a90c57cba0" id="r_aa43559822564ef958dc664a90c57cba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#aa43559822564ef958dc664a90c57cba0">isOpen</a> () const</td></tr>
<tr class="memdesc:aa43559822564ef958dc664a90c57cba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the window is open.  <br /></td></tr>
<tr class="separator:aa43559822564ef958dc664a90c57cba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6090926b477e9d0a83854b94b9e1fd35" id="r_a6090926b477e9d0a83854b94b9e1fd35"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35">pollEvent</a> ()</td></tr>
<tr class="memdesc:a6090926b477e9d0a83854b94b9e1fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the next event from the front of the FIFO event queue, if any, and return it.  <br /></td></tr>
<tr class="separator:a6090926b477e9d0a83854b94b9e1fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5975f6f6a06ecd6c18fa0f62cd1edf7" id="r_ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#ab5975f6f6a06ecd6c18fa0f62cd1edf7">waitEvent</a> (<a class="el" href="classsf_1_1Time.html">Time</a> timeout=<a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a>)</td></tr>
<tr class="memdesc:ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an event and return it.  <br /></td></tr>
<tr class="separator:ab5975f6f6a06ecd6c18fa0f62cd1edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ae79ff4e2da25af1ca3cd06f79557" id="r_ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#ad86ae79ff4e2da25af1ca3cd06f79557">handleEvents</a> (Ts &amp;&amp;... handlers)</td></tr>
<tr class="memdesc:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle all pending events.  <br /></td></tr>
<tr class="separator:ad86ae79ff4e2da25af1ca3cd06f79557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddaa5943f547645079f081422e45c81" id="r_a5ddaa5943f547645079f081422e45c81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a5ddaa5943f547645079f081422e45c81">getPosition</a> () const</td></tr>
<tr class="memdesc:a5ddaa5943f547645079f081422e45c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of the window.  <br /></td></tr>
<tr class="separator:a5ddaa5943f547645079f081422e45c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7282bbf43820f20f41c704c2ab5b86f8" id="r_a7282bbf43820f20f41c704c2ab5b86f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a7282bbf43820f20f41c704c2ab5b86f8">setPosition</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> position)</td></tr>
<tr class="memdesc:a7282bbf43820f20f41c704c2ab5b86f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the position of the window on screen.  <br /></td></tr>
<tr class="separator:a7282bbf43820f20f41c704c2ab5b86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2581f59f35bd379307ea5b6254631c" id="r_abd2581f59f35bd379307ea5b6254631c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#abd2581f59f35bd379307ea5b6254631c">setSize</a> (<a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> size)</td></tr>
<tr class="memdesc:abd2581f59f35bd379307ea5b6254631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the rendering region of the window.  <br /></td></tr>
<tr class="separator:abd2581f59f35bd379307ea5b6254631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742a8f386668f58fe27c0b5f5929de7e" id="r_a742a8f386668f58fe27c0b5f5929de7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a742a8f386668f58fe27c0b5f5929de7e">setMinimumSize</a> (const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;minimumSize)</td></tr>
<tr class="memdesc:a742a8f386668f58fe27c0b5f5929de7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum window rendering region size.  <br /></td></tr>
<tr class="separator:a742a8f386668f58fe27c0b5f5929de7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f856835295a85a2959c962a1616cad" id="r_a65f856835295a85a2959c962a1616cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a65f856835295a85a2959c962a1616cad">setMaximumSize</a> (const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;maximumSize)</td></tr>
<tr class="memdesc:a65f856835295a85a2959c962a1616cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum window rendering region size.  <br /></td></tr>
<tr class="separator:a65f856835295a85a2959c962a1616cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd36ae6244ae1e6d643f6c109e983f8" id="r_accd36ae6244ae1e6d643f6c109e983f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#accd36ae6244ae1e6d643f6c109e983f8">setTitle</a> (const <a class="el" href="classsf_1_1String.html">String</a> &amp;title)</td></tr>
<tr class="memdesc:accd36ae6244ae1e6d643f6c109e983f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the title of the window.  <br /></td></tr>
<tr class="separator:accd36ae6244ae1e6d643f6c109e983f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ab1f9f9dc2312ad0ee83d1ffee9715" id="r_a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a07ab1f9f9dc2312ad0ee83d1ffee9715">setIcon</a> (<a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> size, const std::uint8_t *pixels)</td></tr>
<tr class="memdesc:a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the window's icon.  <br /></td></tr>
<tr class="separator:a07ab1f9f9dc2312ad0ee83d1ffee9715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576488ad202cb2cd4359af94eaba4dd8" id="r_a576488ad202cb2cd4359af94eaba4dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a576488ad202cb2cd4359af94eaba4dd8">setVisible</a> (bool visible)</td></tr>
<tr class="memdesc:a576488ad202cb2cd4359af94eaba4dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the window.  <br /></td></tr>
<tr class="separator:a576488ad202cb2cd4359af94eaba4dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4a3372b2870294d1579d8621fe3c1a" id="r_afa4a3372b2870294d1579d8621fe3c1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#afa4a3372b2870294d1579d8621fe3c1a">setMouseCursorVisible</a> (bool visible)</td></tr>
<tr class="memdesc:afa4a3372b2870294d1579d8621fe3c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show or hide the mouse cursor.  <br /></td></tr>
<tr class="separator:afa4a3372b2870294d1579d8621fe3c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023344922a1e854175c8ca22b072020" id="r_a0023344922a1e854175c8ca22b072020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a0023344922a1e854175c8ca22b072020">setMouseCursorGrabbed</a> (bool grabbed)</td></tr>
<tr class="memdesc:a0023344922a1e854175c8ca22b072020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab or release the mouse cursor.  <br /></td></tr>
<tr class="separator:a0023344922a1e854175c8ca22b072020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07487a3c7e04472b19e96d3a602213ec" id="r_a07487a3c7e04472b19e96d3a602213ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a07487a3c7e04472b19e96d3a602213ec">setMouseCursor</a> (const <a class="el" href="classsf_1_1Cursor.html">Cursor</a> &amp;cursor)</td></tr>
<tr class="memdesc:a07487a3c7e04472b19e96d3a602213ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the displayed cursor to a native system cursor.  <br /></td></tr>
<tr class="separator:a07487a3c7e04472b19e96d3a602213ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1199a64d459ba531deb65f093050a6" id="r_afd1199a64d459ba531deb65f093050a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#afd1199a64d459ba531deb65f093050a6">setKeyRepeatEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:afd1199a64d459ba531deb65f093050a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable automatic key-repeat.  <br /></td></tr>
<tr class="separator:afd1199a64d459ba531deb65f093050a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f939b492c7ea046d4f7b45ac46df1" id="r_ad37f939b492c7ea046d4f7b45ac46df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#ad37f939b492c7ea046d4f7b45ac46df1">setJoystickThreshold</a> (float threshold)</td></tr>
<tr class="memdesc:ad37f939b492c7ea046d4f7b45ac46df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the joystick threshold.  <br /></td></tr>
<tr class="separator:ad37f939b492c7ea046d4f7b45ac46df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448770d2372d8df0a1ad6b1c7cce3c89" id="r_a448770d2372d8df0a1ad6b1c7cce3c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a448770d2372d8df0a1ad6b1c7cce3c89">requestFocus</a> ()</td></tr>
<tr class="memdesc:a448770d2372d8df0a1ad6b1c7cce3c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the current window to be made the active foreground window.  <br /></td></tr>
<tr class="separator:a448770d2372d8df0a1ad6b1c7cce3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87bd19e979c426cb819ccde8c95232e" id="r_ad87bd19e979c426cb819ccde8c95232e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#ad87bd19e979c426cb819ccde8c95232e">hasFocus</a> () const</td></tr>
<tr class="memdesc:ad87bd19e979c426cb819ccde8c95232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the window has the input focus.  <br /></td></tr>
<tr class="separator:ad87bd19e979c426cb819ccde8c95232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af360bb48167c6db4d13e47d23d9c35da" id="r_af360bb48167c6db4d13e47d23d9c35da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#af360bb48167c6db4d13e47d23d9c35da">getNativeHandle</a> () const</td></tr>
<tr class="memdesc:af360bb48167c6db4d13e47d23d9c35da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the OS-specific handle of the window.  <br /></td></tr>
<tr class="separator:af360bb48167c6db4d13e47d23d9c35da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1401a44aa18cff4c23184f909aae82df" id="r_a1401a44aa18cff4c23184f909aae82df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1WindowBase.html#a1401a44aa18cff4c23184f909aae82df">createVulkanSurface</a> (const <a class="el" href="Vulkan_8hpp.html#a09bfb88ab06300f8c5448e7bc53acd9b">VkInstance</a> &amp;instance, <a class="el" href="Vulkan_8hpp.html#a103b6ae069efe31b9adef4ce0b6b6273">VkSurfaceKHR</a> &amp;surface, const VkAllocationCallbacks *allocator=nullptr)</td></tr>
<tr class="memdesc:a1401a44aa18cff4c23184f909aae82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> rendering surface.  <br /></td></tr>
<tr class="separator:a1401a44aa18cff4c23184f909aae82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee353fc2cd35edf0747e710301af3e4c" id="r_aee353fc2cd35edf0747e710301af3e4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#aee353fc2cd35edf0747e710301af3e4c">clear</a> (<a class="el" href="classsf_1_1Color.html">Color</a> color=<a class="el" href="classsf_1_1Color.html#a77c688197b981338f0b19dc58bd2facd">Color::Black</a>)</td></tr>
<tr class="memdesc:aee353fc2cd35edf0747e710301af3e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color.  <br /></td></tr>
<tr class="separator:aee353fc2cd35edf0747e710301af3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4dd9e35771ba842f0feb4ba52cebb9" id="r_a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a6b4dd9e35771ba842f0feb4ba52cebb9">clear</a> (<a class="el" href="classsf_1_1Color.html">Color</a> color, <a class="el" href="structsf_1_1StencilValue.html">StencilValue</a> stencilValue)</td></tr>
<tr class="memdesc:a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color and stencil value.  <br /></td></tr>
<tr class="separator:a6b4dd9e35771ba842f0feb4ba52cebb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5756ecc36a0ad169809063f8f2563cbe" id="r_a5756ecc36a0ad169809063f8f2563cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a5756ecc36a0ad169809063f8f2563cbe">clearStencil</a> (<a class="el" href="structsf_1_1StencilValue.html">StencilValue</a> stencilValue)</td></tr>
<tr class="memdesc:a5756ecc36a0ad169809063f8f2563cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil buffer to a specific value.  <br /></td></tr>
<tr class="separator:a5756ecc36a0ad169809063f8f2563cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063db6dd0a14913504af30e50cb6d946" id="r_a063db6dd0a14913504af30e50cb6d946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a063db6dd0a14913504af30e50cb6d946">setView</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view)</td></tr>
<tr class="memdesc:a063db6dd0a14913504af30e50cb6d946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current active view.  <br /></td></tr>
<tr class="separator:a063db6dd0a14913504af30e50cb6d946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8dc5a1f4abbe15a3fbb915844c7ea" id="r_adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#adbf8dc5a1f4abbe15a3fbb915844c7ea">getView</a> () const</td></tr>
<tr class="memdesc:adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view currently in use in the render target.  <br /></td></tr>
<tr class="separator:adbf8dc5a1f4abbe15a3fbb915844c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7741129e3ef7ab4f0a40024fca13480c" id="r_a7741129e3ef7ab4f0a40024fca13480c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c">getDefaultView</a> () const</td></tr>
<tr class="memdesc:a7741129e3ef7ab4f0a40024fca13480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default view of the render target.  <br /></td></tr>
<tr class="separator:a7741129e3ef7ab4f0a40024fca13480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d462915dc2a1fae2ebfb3300382ac" id="r_a865d462915dc2a1fae2ebfb3300382ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a865d462915dc2a1fae2ebfb3300382ac">getViewport</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a865d462915dc2a1fae2ebfb3300382ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport of a view, applied to this render target.  <br /></td></tr>
<tr class="separator:a865d462915dc2a1fae2ebfb3300382ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28db5c204007c2ccc806462ed6712da6" id="r_a28db5c204007c2ccc806462ed6712da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a28db5c204007c2ccc806462ed6712da6">getScissor</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a28db5c204007c2ccc806462ed6712da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scissor rectangle of a view, applied to this render target.  <br /></td></tr>
<tr class="separator:a28db5c204007c2ccc806462ed6712da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce02e4fd30e065c4dbeec239ae579b3" id="r_a5ce02e4fd30e065c4dbeec239ae579b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a5ce02e4fd30e065c4dbeec239ae579b3">mapPixelToCoords</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> point) const</td></tr>
<tr class="memdesc:a5ce02e4fd30e065c4dbeec239ae579b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates, using the current view.  <br /></td></tr>
<tr class="separator:a5ce02e4fd30e065c4dbeec239ae579b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c5ec0787ffdcabfcee0f2b88dd4536" id="r_af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#af7c5ec0787ffdcabfcee0f2b88dd4536">mapPixelToCoords</a> (<a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates.  <br /></td></tr>
<tr class="separator:af7c5ec0787ffdcabfcee0f2b88dd4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473e0723ba16cf913deb03774c8458c" id="r_ab473e0723ba16cf913deb03774c8458c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#ab473e0723ba16cf913deb03774c8458c">mapCoordsToPixel</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> point) const</td></tr>
<tr class="memdesc:ab473e0723ba16cf913deb03774c8458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates, using the current view.  <br /></td></tr>
<tr class="separator:ab473e0723ba16cf913deb03774c8458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a8da6e2a9e3ce5f36344e3d8e7c41a" id="r_a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a07a8da6e2a9e3ce5f36344e3d8e7c41a">mapCoordsToPixel</a> (<a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates.  <br /></td></tr>
<tr class="separator:a07a8da6e2a9e3ce5f36344e3d8e7c41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12417a3bcc245c41d957b29583556f39" id="r_a12417a3bcc245c41d957b29583556f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a> (const <a class="el" href="classsf_1_1Drawable.html">Drawable</a> &amp;drawable, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a12417a3bcc245c41d957b29583556f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a drawable object to the render target.  <br /></td></tr>
<tr class="separator:a12417a3bcc245c41d957b29583556f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bc94057799eb9f8a18ac5fdfd9b73" id="r_a976bc94057799eb9f8a18ac5fdfd9b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a976bc94057799eb9f8a18ac5fdfd9b73">draw</a> (const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *vertices, std::size_t vertexCount, <a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a976bc94057799eb9f8a18ac5fdfd9b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by an array of vertices.  <br /></td></tr>
<tr class="separator:a976bc94057799eb9f8a18ac5fdfd9b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc4d06f081d36ca1e8f1a1298d49abc" id="r_a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a3dc4d06f081d36ca1e8f1a1298d49abc">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <br /></td></tr>
<tr class="separator:a3dc4d06f081d36ca1e8f1a1298d49abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb25d4557a30146b24b25b242310ea" id="r_a07cb25d4557a30146b24b25b242310ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a07cb25d4557a30146b24b25b242310ea">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, std::size_t firstVertex, std::size_t vertexCount, const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a07cb25d4557a30146b24b25b242310ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <br /></td></tr>
<tr class="separator:a07cb25d4557a30146b24b25b242310ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1998464ccc54e789aaf990242b47f7" id="r_a8d1998464ccc54e789aaf990242b47f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a> ()</td></tr>
<tr class="memdesc:a8d1998464ccc54e789aaf990242b47f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current OpenGL render states and matrices.  <br /></td></tr>
<tr class="separator:a8d1998464ccc54e789aaf990242b47f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a98401113df931ddcd54c080f7aa8e" id="r_ad5a98401113df931ddcd54c080f7aa8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a> ()</td></tr>
<tr class="memdesc:ad5a98401113df931ddcd54c080f7aa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously saved OpenGL render states and matrices.  <br /></td></tr>
<tr class="separator:ad5a98401113df931ddcd54c080f7aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7504990d27dada4bfe3c7866920765" id="r_aac7504990d27dada4bfe3c7866920765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#aac7504990d27dada4bfe3c7866920765">resetGLStates</a> ()</td></tr>
<tr class="memdesc:aac7504990d27dada4bfe3c7866920765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal OpenGL states so that the target is ready for drawing.  <br /></td></tr>
<tr class="separator:aac7504990d27dada4bfe3c7866920765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aab231189dcb7d529d7d535772ac5ab01" id="r_aab231189dcb7d529d7d535772ac5ab01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab231189dcb7d529d7d535772ac5ab01">onCreate</a> () override</td></tr>
<tr class="memdesc:aab231189dcb7d529d7d535772ac5ab01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been created.  <br /></td></tr>
<tr class="separator:aab231189dcb7d529d7d535772ac5ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223392a3ebd6581bd7b2c5e211ba072" id="r_a5223392a3ebd6581bd7b2c5e211ba072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5223392a3ebd6581bd7b2c5e211ba072">onResize</a> () override</td></tr>
<tr class="memdesc:a5223392a3ebd6581bd7b2c5e211ba072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called after the window has been resized.  <br /></td></tr>
<tr class="separator:a5223392a3ebd6581bd7b2c5e211ba072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af530274b34159d644e509b4b4dc43eb7" id="r_af530274b34159d644e509b4b4dc43eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#af530274b34159d644e509b4b4dc43eb7">initialize</a> ()</td></tr>
<tr class="memdesc:af530274b34159d644e509b4b4dc43eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the common initialization step after creation.  <br /></td></tr>
<tr class="separator:af530274b34159d644e509b4b4dc43eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">Window</a> that can serve as a target for 2D drawing. </p>
<p><code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code> is the main class of the Graphics module.</p>
<p>It defines an OS window that can be painted using the other classes of the graphics module.</p>
<p><code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code> is derived from <code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code>, thus it inherits all its features: events, window management, OpenGL rendering, etc. See the documentation of <code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code> for a more complete description of all these features, as well as code examples.</p>
<p>On top of that, <code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code> adds more features related to 2D drawing with the graphics module (see its base class <code><a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a></code> for more details). Here is a typical rendering and event loop with a <code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Declare and create a new render-window</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1RenderWindow.html">sf::RenderWindow</a> window(<a class="code hl_class" href="classsf_1_1VideoMode.html">sf::VideoMode</a>({800, 600}), <span class="stringliteral">&quot;SFML window&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Limit the framerate to 60 frames per second (this step is optional)</span></div>
<div class="line">window.<a class="code hl_function" href="classsf_1_1Window.html#af4322d315baf93405bf0d5087ad5e784">setFramerateLimit</a>(60);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The main loop - ends as soon as the window is closed</span></div>
<div class="line"><span class="keywordflow">while</span> (window.<a class="code hl_function" href="classsf_1_1WindowBase.html#aa43559822564ef958dc664a90c57cba0">isOpen</a>())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Event processing</span></div>
<div class="line">   <span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.<a class="code hl_function" href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35">pollEvent</a>())</div>
<div class="line">   {</div>
<div class="line">       <span class="comment">// Request for closing the window</span></div>
<div class="line">       <span class="keywordflow">if</span> (event-&gt;is&lt;<a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&gt;())</div>
<div class="line">           window.<a class="code hl_function" href="classsf_1_1Window.html#ab1d808a3682db8d113d67354bcbd717d">close</a>();</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Clear the whole window before rendering a new frame</span></div>
<div class="line">   window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#aee353fc2cd35edf0747e710301af3e4c">clear</a>();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Draw some graphical entities</span></div>
<div class="line">   window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(sprite);</div>
<div class="line">   window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(circle);</div>
<div class="line">   window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(text);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// End the current frame and display its contents on screen</span></div>
<div class="line">   window.<a class="code hl_function" href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a">display</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_a12417a3bcc245c41d957b29583556f39"><div class="ttname"><a href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a></div><div class="ttdeci">void draw(const Drawable &amp;drawable, const RenderStates &amp;states=RenderStates::Default)</div><div class="ttdoc">Draw a drawable object to the render target.</div></div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_aee353fc2cd35edf0747e710301af3e4c"><div class="ttname"><a href="classsf_1_1RenderTarget.html#aee353fc2cd35edf0747e710301af3e4c">sf::RenderTarget::clear</a></div><div class="ttdeci">void clear(Color color=Color::Black)</div><div class="ttdoc">Clear the entire target with a single color.</div></div>
<div class="ttc" id="aclasssf_1_1RenderWindow_html"><div class="ttname"><a href="classsf_1_1RenderWindow.html">sf::RenderWindow</a></div><div class="ttdoc">Window that can serve as a target for 2D drawing.</div><div class="ttdef"><b>Definition</b> <a href="RenderWindow_8hpp_source.html#l00054">RenderWindow.hpp:55</a></div></div>
<div class="ttc" id="aclasssf_1_1VideoMode_html"><div class="ttname"><a href="classsf_1_1VideoMode.html">sf::VideoMode</a></div><div class="ttdoc">VideoMode defines a video mode (size, bpp)</div><div class="ttdef"><b>Definition</b> <a href="VideoMode_8hpp_source.html#l00043">VideoMode.hpp:44</a></div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html_a6090926b477e9d0a83854b94b9e1fd35"><div class="ttname"><a href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35">sf::WindowBase::pollEvent</a></div><div class="ttdeci">std::optional&lt; Event &gt; pollEvent()</div><div class="ttdoc">Pop the next event from the front of the FIFO event queue, if any, and return it.</div></div>
<div class="ttc" id="aclasssf_1_1WindowBase_html_aa43559822564ef958dc664a90c57cba0"><div class="ttname"><a href="classsf_1_1WindowBase.html#aa43559822564ef958dc664a90c57cba0">sf::WindowBase::isOpen</a></div><div class="ttdeci">bool isOpen() const</div><div class="ttdoc">Tell whether or not the window is open.</div></div>
<div class="ttc" id="aclasssf_1_1Window_html_ab1d808a3682db8d113d67354bcbd717d"><div class="ttname"><a href="classsf_1_1Window.html#ab1d808a3682db8d113d67354bcbd717d">sf::Window::close</a></div><div class="ttdeci">void close() override</div><div class="ttdoc">Close the window and destroy all the attached resources.</div></div>
<div class="ttc" id="aclasssf_1_1Window_html_adabf839cb103ac96cfc82f781638772a"><div class="ttname"><a href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a">sf::Window::display</a></div><div class="ttdeci">void display()</div><div class="ttdoc">Display on screen what has been rendered to the window so far.</div></div>
<div class="ttc" id="aclasssf_1_1Window_html_af4322d315baf93405bf0d5087ad5e784"><div class="ttname"><a href="classsf_1_1Window.html#af4322d315baf93405bf0d5087ad5e784">sf::Window::setFramerateLimit</a></div><div class="ttdeci">void setFramerateLimit(unsigned int limit)</div><div class="ttdoc">Limit the framerate to a maximum fixed frequency.</div></div>
<div class="ttc" id="astructsf_1_1Event_1_1Closed_html"><div class="ttname"><a href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a></div><div class="ttdoc">Closed event subtype.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00053">Event.hpp:54</a></div></div>
</div><!-- fragment --><p>Like <code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code>, <code><a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a></code> is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands.</p>
<div class="fragment"><div class="line"><span class="comment">// Create the render window</span></div>
<div class="line"><a class="code hl_class" href="classsf_1_1RenderWindow.html">sf::RenderWindow</a> window(<a class="code hl_class" href="classsf_1_1VideoMode.html">sf::VideoMode</a>({800, 600}), <span class="stringliteral">&quot;SFML OpenGL&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a sprite and a text to display</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsf_1_1Texture.html">sf::Texture</a> texture(<span class="stringliteral">&quot;circle.png&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classsf_1_1Sprite.html">sf::Sprite</a> sprite(texture);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classsf_1_1Font.html">sf::Font</a> font(<span class="stringliteral">&quot;arial.ttf&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classsf_1_1Text.html">sf::Text</a> text(font);</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform OpenGL initializations</span></div>
<div class="line">glMatrixMode(GL_PROJECTION);</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start the rendering loop</span></div>
<div class="line">while (window.<a class="code hl_function" href="classsf_1_1WindowBase.html#aa43559822564ef958dc664a90c57cba0">isOpen</a>())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Process events</span></div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw a background sprite</span></div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a>();</div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(sprite);</div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw a 3D object using OpenGL</span></div>
<div class="line">    glBegin(GL_TRIANGLES);</div>
<div class="line">        glVertex3f(...);</div>
<div class="line">        ...</div>
<div class="line">    glEnd();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw text on top of the 3D object</span></div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a>();</div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(text);</div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Finally, display the rendered frame on screen</span></div>
<div class="line">    window.<a class="code hl_function" href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a">display</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclasssf_1_1Font_html"><div class="ttname"><a href="classsf_1_1Font.html">sf::Font</a></div><div class="ttdoc">Class for loading and manipulating character fonts.</div><div class="ttdef"><b>Definition</b> <a href="Font_8hpp_source.html#l00063">Font.hpp:64</a></div></div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_a8d1998464ccc54e789aaf990242b47f7"><div class="ttname"><a href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">sf::RenderTarget::pushGLStates</a></div><div class="ttdeci">void pushGLStates()</div><div class="ttdoc">Save the current OpenGL render states and matrices.</div></div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_ad5a98401113df931ddcd54c080f7aa8e"><div class="ttname"><a href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">sf::RenderTarget::popGLStates</a></div><div class="ttdeci">void popGLStates()</div><div class="ttdoc">Restore the previously saved OpenGL render states and matrices.</div></div>
<div class="ttc" id="aclasssf_1_1Sprite_html"><div class="ttname"><a href="classsf_1_1Sprite.html">sf::Sprite</a></div><div class="ttdoc">Drawable representation of a texture, with its own transformations, color, etc.</div><div class="ttdef"><b>Definition</b> <a href="Sprite_8hpp_source.html#l00050">Sprite.hpp:51</a></div></div>
<div class="ttc" id="aclasssf_1_1Text_html"><div class="ttname"><a href="classsf_1_1Text.html">sf::Text</a></div><div class="ttdoc">Graphical text that can be drawn to a render target.</div><div class="ttdef"><b>Definition</b> <a href="Text_8hpp_source.html#l00056">Text.hpp:57</a></div></div>
<div class="ttc" id="aclasssf_1_1Texture_html"><div class="ttname"><a href="classsf_1_1Texture.html">sf::Texture</a></div><div class="ttdoc">Image living on the graphics card that can be used for drawing.</div><div class="ttdef"><b>Definition</b> <a href="Texture_8hpp_source.html#l00055">Texture.hpp:56</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code>, <code><a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a></code>, <code><a class="el" href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a></code>, <code><a class="el" href="classsf_1_1View.html" title="2D camera that defines what region is shown on screen">sf::View</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="RenderWindow_8hpp_source.html#l00054">54</a> of file <a class="el" href="RenderWindow_8hpp_source.html">RenderWindow.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add082448ad1384c0bd475a70cf4f7df1" name="add082448ad1384c0bd475a70cf4f7df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add082448ad1384c0bd475a70cf4f7df1">&#9670;&#160;</a></span>RenderWindow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderWindow::RenderWindow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor doesn't actually create the window, use the other constructors or call <code><a class="el" href="classsf_1_1Window.html#ae77f112046c240b477963326e2363e18" title="Create (or recreate) the window.">create()</a></code> to do so. </p>

</div>
</div>
<a id="a417c0ea193537b0104b6f6c52e9d7163" name="a417c0ea193537b0104b6f6c52e9d7163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417c0ea193537b0104b6f6c52e9d7163">&#9670;&#160;</a></span>RenderWindow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderWindow::RenderWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>style</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga5e7da6549090361249790ccb464158cca5597cd420fc461807e4a201c92adea37">Style::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new window. </p>
<p>This constructor creates the window with the size and pixel depth defined in <code>mode</code>. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...).</p>
<p>The last parameter is an optional structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td>Window style, a bitwise OR combination of <code><a class="el" href="namespacesf_1_1Style.html">sf::Style</a></code> enumerators </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af405d17c1e5e042886afff04b3a77f97" name="af405d17c1e5e042886afff04b3a77f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af405d17c1e5e042886afff04b3a77f97">&#9670;&#160;</a></span>RenderWindow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderWindow::RenderWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new window. </p>
<p>This constructor creates the window with the size and pixel depth defined in <code>mode</code>. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<p>The last parameter is an optional structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19debea720c5cb4b7c19886f464ae1c7" name="a19debea720c5cb4b7c19886f464ae1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19debea720c5cb4b7c19886f464ae1c7">&#9670;&#160;</a></span>RenderWindow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderWindow::RenderWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the window from an existing control. </p>
<p>Use this constructor if you want to create an SFML rendering area into an already existing control.</p>
<p>The second parameter is an optional structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control (<em>HWND</em> on Windows, <em>Window</em> on Linux/FreeBSD, <em>NSWindow</em> on macOS) </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6b4dd9e35771ba842f0feb4ba52cebb9" name="a6b4dd9e35771ba842f0feb4ba52cebb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4dd9e35771ba842f0feb4ba52cebb9">&#9670;&#160;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Color.html">Color</a></td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsf_1_1StencilValue.html">StencilValue</a></td>          <td class="paramname"><span class="paramname"><em>stencilValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the entire target with a single color and stencil value. </p>
<p>The specified stencil value is truncated to the bit width of the current stencil buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
    <tr><td class="paramname">stencilValue</td><td>Stencil value to clear to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee353fc2cd35edf0747e710301af3e4c" name="aee353fc2cd35edf0747e710301af3e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee353fc2cd35edf0747e710301af3e4c">&#9670;&#160;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Color.html">Color</a></td>          <td class="paramname"><span class="paramname"><em>color</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsf_1_1Color.html#a77c688197b981338f0b19dc58bd2facd">Color::Black</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the entire target with a single color. </p>
<p>This function is usually called once every frame, to clear the previous contents of the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>Fill color to use to clear the render target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5756ecc36a0ad169809063f8f2563cbe" name="a5756ecc36a0ad169809063f8f2563cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5756ecc36a0ad169809063f8f2563cbe">&#9670;&#160;</a></span>clearStencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::clearStencil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsf_1_1StencilValue.html">StencilValue</a></td>          <td class="paramname"><span class="paramname"><em>stencilValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stencil buffer to a specific value. </p>
<p>The specified value is truncated to the bit width of the current stencil buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilValue</td><td>Stencil value to clear to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1d808a3682db8d113d67354bcbd717d" name="ab1d808a3682db8d113d67354bcbd717d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d808a3682db8d113d67354bcbd717d">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::close </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the window and destroy all the attached resources. </p>
<p>After calling this function, the <code><a class="el" href="classsf_1_1Window.html" title="Window that serves as a target for OpenGL rendering.">sf::Window</a></code> instance remains valid and you can call <code><a class="el" href="classsf_1_1Window.html#ae77f112046c240b477963326e2363e18" title="Create (or recreate) the window.">create()</a></code> to recreate the window. All other functions such as <code><a class="el" href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent()</a></code> or <code><a class="el" href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a" title="Display on screen what has been rendered to the window so far.">display()</a></code> will still work (i.e. you don't have to test <code><a class="el" href="classsf_1_1WindowBase.html#aa43559822564ef958dc664a90c57cba0" title="Tell whether or not the window is open.">isOpen()</a></code> every time), and will have no effect on closed windows. </p>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a9a5ea0ba0ab584dbd11bbfea233b457f">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a17af5e75b858635f45ad46ce91668ce8" name="a17af5e75b858635f45ad46ce91668ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17af5e75b858635f45ad46ce91668ce8">&#9670;&#160;</a></span>create() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a1730d462059617d78f08c0e4eeee771a">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a3667f889b2b288c13fe8f039cbad9931" name="a3667f889b2b288c13fe8f039cbad9931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3667f889b2b288c13fe8f039cbad9931">&#9670;&#160;</a></span>create() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<p>The last parameter is a structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace10c7fc5904ddff72a0fede61758679" name="ace10c7fc5904ddff72a0fede61758679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace10c7fc5904ddff72a0fede61758679">&#9670;&#160;</a></span>create() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<p>The last parameter is a structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td>Window style, a bitwise OR combination of <code><a class="el" href="namespacesf_1_1Style.html">sf::Style</a></code> enumerators </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77f112046c240b477963326e2363e18" name="ae77f112046c240b477963326e2363e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77f112046c240b477963326e2363e18">&#9670;&#160;</a></span>create() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1VideoMode.html">VideoMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t</td>          <td class="paramname"><span class="paramname"><em>style</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga5e7da6549090361249790ccb464158cca5597cd420fc461807e4a201c92adea37">Style::Default</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__window.html#ga504e2cd8fc6a852463f8d049db1151e5">State</a></td>          <td class="paramname"><span class="paramname"><em>state</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5ab13311ab51c4c34757f67f26580018dd">State::Windowed</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window. </p>
<p>If the window was already created, it closes it first. If <code>state</code> is <code><a class="el" href="group__window.html#gga504e2cd8fc6a852463f8d049db1151e5a0829ea6734059d66e6bf87096b215dc1" title="Fullscreen window.">State::Fullscreen</a></code>, then <code>mode</code> must be a valid video mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Video mode to use (defines the width, height and depth of the rendering area of the window) </td></tr>
    <tr><td class="paramname">title</td><td>Title of the window </td></tr>
    <tr><td class="paramname">style</td><td>Window style, a bitwise OR combination of <code><a class="el" href="namespacesf_1_1Style.html">sf::Style</a></code> enumerators </td></tr>
    <tr><td class="paramname">state</td><td>Window state </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a612f5918f3cb042fcf1189fed24b91d4">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a5246d47ddea8ad787be150e09df1fc53" name="a5246d47ddea8ad787be150e09df1fc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5246d47ddea8ad787be150e09df1fc53">&#9670;&#160;</a></span>create() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window from an existing control. </p>
<p>Use this function if you want to create an OpenGL rendering area into an already existing control. If the window was already created, it closes it first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a4e4968e15e33fd70629983f635bcc21c">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a064dd5dd7bb337fb9f5635f580081a1e" name="a064dd5dd7bb337fb9f5635f580081a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064dd5dd7bb337fb9f5635f580081a1e">&#9670;&#160;</a></span>create() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sf::Window::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a></td>          <td class="paramname"><span class="paramname"><em>handle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create (or recreate) the window from an existing control. </p>
<p>Use this function if you want to create an OpenGL rendering area into an already existing control. If the window was already created, it closes it first.</p>
<p>The second parameter is an optional structure specifying advanced OpenGL context settings such as anti-aliasing, depth-buffer bits, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Platform-specific handle of the control </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1401a44aa18cff4c23184f909aae82df" name="a1401a44aa18cff4c23184f909aae82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1401a44aa18cff4c23184f909aae82df">&#9670;&#160;</a></span>createVulkanSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::createVulkanSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="Vulkan_8hpp.html#a09bfb88ab06300f8c5448e7bc53acd9b">VkInstance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Vulkan_8hpp.html#a103b6ae069efe31b9adef4ce0b6b6273">VkSurfaceKHR</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> rendering surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td><a class="el" href="namespacesf_1_1Vulkan.html" title="Vulkan helper functions.">Vulkan</a> instance </td></tr>
    <tr><td class="paramname">surface</td><td>Created surface </td></tr>
    <tr><td class="paramname">allocator</td><td>Allocator to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if surface creation was successful, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="adabf839cb103ac96cfc82f781638772a" name="adabf839cb103ac96cfc82f781638772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabf839cb103ac96cfc82f781638772a">&#9670;&#160;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::display </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Display on screen what has been rendered to the window so far. </p>
<p>This function is typically called after all OpenGL rendering has been done for the current frame, in order to show it on screen. </p>

</div>
</div>
<a id="a12417a3bcc245c41d957b29583556f39" name="a12417a3bcc245c41d957b29583556f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12417a3bcc245c41d957b29583556f39">&#9670;&#160;</a></span>draw() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Drawable.html">Drawable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drawable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a drawable object to the render target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>Object to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976bc94057799eb9f8a18ac5fdfd9b73" name="a976bc94057799eb9f8a18ac5fdfd9b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976bc94057799eb9f8a18ac5fdfd9b73">&#9670;&#160;</a></span>draw() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsf_1_1Vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw primitives defined by an array of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Pointer to the vertices </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in the array </td></tr>
    <tr><td class="paramname">type</td><td>Type of primitives to draw </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dc4d06f081d36ca1e8f1a1298d49abc" name="a3dc4d06f081d36ca1e8f1a1298d49abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc4d06f081d36ca1e8f1a1298d49abc">&#9670;&#160;</a></span>draw() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw primitives defined by a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cb25d4557a30146b24b25b242310ea" name="a07cb25d4557a30146b24b25b242310ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cb25d4557a30146b24b25b242310ea">&#9670;&#160;</a></span>draw() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::draw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>firstVertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>vertexCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1RenderStates.html">RenderStates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>states</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw primitives defined by a vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td><a class="el" href="structsf_1_1Vertex.html" title="Point with color and texture coordinates.">Vertex</a> buffer </td></tr>
    <tr><td class="paramname">firstVertex</td><td>Index of the first vertex to render </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices to render </td></tr>
    <tr><td class="paramname">states</td><td>Render states to use for drawing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7741129e3ef7ab4f0a40024fca13480c" name="a7741129e3ef7ab4f0a40024fca13480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7741129e3ef7ab4f0a40024fca13480c">&#9670;&#160;</a></span>getDefaultView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.html">View</a> &amp; sf::RenderTarget::getDefaultView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default view of the render target. </p>
<p>The default view has the initial size of the render target, and never changes after the target has been created.</p>
<dl class="section return"><dt>Returns</dt><dd>The default view of the render target</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a></code>, <code><a class="el" href="classsf_1_1RenderTarget.html#adbf8dc5a1f4abbe15a3fbb915844c7ea" title="Get the view currently in use in the render target.">getView</a></code> </dd></dl>

</div>
</div>
<a id="af360bb48167c6db4d13e47d23d9c35da" name="af360bb48167c6db4d13e47d23d9c35da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af360bb48167c6db4d13e47d23d9c35da">&#9670;&#160;</a></span>getNativeHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289">WindowHandle</a> sf::WindowBase::getNativeHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the OS-specific handle of the window. </p>
<p>The type of the returned handle is <code><a class="el" href="group__window.html#ga9858f04701033cd01859037d8dafd289" title="Low-level window handle type, specific to each platform.">sf::WindowHandle</a></code>, which is a type alias to the handle type defined by the OS. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed.</p>
<dl class="section return"><dt>Returns</dt><dd>System handle of the window </dd></dl>

</div>
</div>
<a id="a5ddaa5943f547645079f081422e45c81" name="a5ddaa5943f547645079f081422e45c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddaa5943f547645079f081422e45c81">&#9670;&#160;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::WindowBase::getPosition </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of the window. </p>
<dl class="section return"><dt>Returns</dt><dd>Position of the window, in pixels</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#a7282bbf43820f20f41c704c2ab5b86f8" title="Change the position of the window on screen.">setPosition</a></code> </dd></dl>

</div>
</div>
<a id="a28db5c204007c2ccc806462ed6712da6" name="a28db5c204007c2ccc806462ed6712da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28db5c204007c2ccc806462ed6712da6">&#9670;&#160;</a></span>getScissor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a> sf::RenderTarget::getScissor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scissor rectangle of a view, applied to this render target. </p>
<p>The scissor rectangle is defined in the view as a ratio. This function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the scissor rectangle actually covers in the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the scissor rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scissor rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a id="a0605afbaceb02b098f9d731b7ab4203d" name="a0605afbaceb02b098f9d731b7ab4203d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0605afbaceb02b098f9d731b7ab4203d">&#9670;&#160;</a></span>getSettings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp; sf::Window::getSettings </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the settings of the OpenGL context of the window. </p>
<p>Note that these settings may be different from what was passed to the constructor or the <code><a class="el" href="classsf_1_1Window.html#ae77f112046c240b477963326e2363e18" title="Create (or recreate) the window.">create()</a></code> function, if one or more settings were not supported. In this case, SFML chose the closest match.</p>
<dl class="section return"><dt>Returns</dt><dd>Structure containing the OpenGL context settings </dd></dl>

</div>
</div>
<a id="af5d9a6263e05fd4ed4b31a5c202cc642" name="af5d9a6263e05fd4ed4b31a5c202cc642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d9a6263e05fd4ed4b31a5c202cc642">&#9670;&#160;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> sf::RenderWindow::getSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the rendering region of the window. </p>
<p>The size doesn't include the titlebar and borders of the window.</p>
<dl class="section return"><dt>Returns</dt><dd>Size in pixels </dd></dl>

<p>Implements <a class="el" href="classsf_1_1RenderTarget.html#a2e5ade2457d9fb4c4907ae5b3d9e94a5">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="adbf8dc5a1f4abbe15a3fbb915844c7ea" name="adbf8dc5a1f4abbe15a3fbb915844c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf8dc5a1f4abbe15a3fbb915844c7ea">&#9670;&#160;</a></span>getView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1View.html">View</a> &amp; sf::RenderTarget::getView </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the view currently in use in the render target. </p>
<dl class="section return"><dt>Returns</dt><dd>The view object that is currently used</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#a063db6dd0a14913504af30e50cb6d946" title="Change the current active view.">setView</a></code>, <code><a class="el" href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView</a></code> </dd></dl>

</div>
</div>
<a id="a865d462915dc2a1fae2ebfb3300382ac" name="a865d462915dc2a1fae2ebfb3300382ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865d462915dc2a1fae2ebfb3300382ac">&#9670;&#160;</a></span>getViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#add1cf75a734c8414680b0424145c30b1">IntRect</a> sf::RenderTarget::getViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the viewport of a view, applied to this render target. </p>
<p>The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The view for which we want to compute the viewport</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Viewport rectangle, expressed in pixels </dd></dl>

</div>
</div>
<a id="ad86ae79ff4e2da25af1ca3cd06f79557" name="ad86ae79ff4e2da25af1ca3cd06f79557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86ae79ff4e2da25af1ca3cd06f79557">&#9670;&#160;</a></span>handleEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::handleEvents </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>handlers</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle all pending events. </p>
<p>This function is not blocking: if there's no pending event then it will return without calling any of the handlers.</p>
<p>This function can take a variadic list of event handlers that each take a concrete event type as a single parameter. The event handlers can be any kind of callable object that has an <code>operator()</code> defined for a specific event type. Additionally a generic callable can also be provided that will be invoked for every event type. If both types of callables are provided, the callables taking concrete event types will be preferred over the generic callable by overload resolution. Generic callables can be used to customize handler dispatching based on the deduced type of the event and other information available at compile time.</p>
<p>Examples of callables:</p><ul>
<li>Lambda expressions: <code>[&amp;](const <a class="el" href="structsf_1_1Event_1_1KeyPressed.html" title="Key pressed event subtype.">sf::Event::KeyPressed</a>) { ... }</code></li>
<li>Free functions: <code>void handler(const <a class="el" href="structsf_1_1Event_1_1KeyPressed.html" title="Key pressed event subtype.">sf::Event::KeyPressed</a>&amp;) { ... }</code></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Only provide handlers for concrete event types</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&amp;) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&amp; keyPress) { <span class="comment">/* handle event */</span> }</div>
<div class="line">);</div>
<div class="ttc" id="astructsf_1_1Event_1_1KeyPressed_html"><div class="ttname"><a href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a></div><div class="ttdoc">Key pressed event subtype.</div><div class="ttdef"><b>Definition</b> <a href="Event_8hpp_source.html#l00095">Event.hpp:96</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Provide a generic event handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(event)&gt;, <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle Closed</span></div>
<div class="line">            handleClosed();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(event)&gt;, <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&gt;)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle KeyPressed</span></div>
<div class="line">            handleKeyPressed(event);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Handle non-KeyPressed</span></div>
<div class="line">            handleOtherEvents(event);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Provide handlers for concrete types and fall back to generic handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1Closed.html">sf::Event::Closed</a>&amp;) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <a class="code hl_struct" href="structsf_1_1Event_1_1KeyPressed.html">sf::Event::KeyPressed</a>&amp; keyPress) { <span class="comment">/* handle event */</span> },</div>
<div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) { <span class="comment">/* handle all other events */</span> }</div>
<div class="line">);</div>
</div><!-- fragment --><p>Calling member functions is supported through lambda expressions. </p><div class="fragment"><div class="line"><span class="comment">// Provide a generic event handler</span></div>
<div class="line">window.handleEvents(</div>
<div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) { handle(event); }</div>
<div class="line">);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlers</td><td>A variadic list of callables that take a specific event as their only parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#ab5975f6f6a06ecd6c18fa0f62cd1edf7" title="Wait for an event and return it.">waitEvent</a></code>, <code><a class="el" href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent</a></code> </dd></dl>

</div>
</div>
<a id="ad87bd19e979c426cb819ccde8c95232e" name="ad87bd19e979c426cb819ccde8c95232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87bd19e979c426cb819ccde8c95232e">&#9670;&#160;</a></span>hasFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::hasFocus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the window has the input focus. </p>
<p>At any given time, only one window may have the input focus to receive input events such as keystrokes or most mouse events.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if window has focus, <code>false</code> otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#a448770d2372d8df0a1ad6b1c7cce3c89" title="Request the current window to be made the active foreground window.">requestFocus</a></code> </dd></dl>

</div>
</div>
<a id="af530274b34159d644e509b4b4dc43eb7" name="af530274b34159d644e509b4b4dc43eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af530274b34159d644e509b4b4dc43eb7">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the common initialization step after creation. </p>
<p>The derived classes must call this function after the target is created and ready for drawing. </p>

</div>
</div>
<a id="aa43559822564ef958dc664a90c57cba0" name="aa43559822564ef958dc664a90c57cba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43559822564ef958dc664a90c57cba0">&#9670;&#160;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::WindowBase::isOpen </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether or not the window is open. </p>
<p>This function returns whether or not the window exists. Note that a hidden window (<code>setVisible(false)</code>) is open (therefore this function would return <code>true</code>).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the window is open, <code>false</code> if it has been closed </dd></dl>

</div>
</div>
<a id="a1e57e5284d9abf1095171d157dd27b3f" name="a1e57e5284d9abf1095171d157dd27b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e57e5284d9abf1095171d157dd27b3f">&#9670;&#160;</a></span>isSrgb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderWindow::isSrgb </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell if the window will use sRGB encoding when drawing on it. </p>
<p>You can request sRGB encoding for a window by having the sRgbCapable flag set in the <code><a class="el" href="structsf_1_1ContextSettings.html" title="Structure defining the settings of the OpenGL context attached to a window.">ContextSettings</a></code></p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the window use sRGB encoding, <code>false</code> otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="classsf_1_1RenderTarget.html#aea6b58e5b2423c917e2664ecd4952687">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="ab473e0723ba16cf913deb03774c8458c" name="ab473e0723ba16cf913deb03774c8458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473e0723ba16cf913deb03774c8458c">&#9670;&#160;</a></span>mapCoordsToPixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::RenderTarget::mapCoordsToPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from world coordinates to target coordinates, using the current view. </p>
<p>This function is an overload of the <code>mapCoordsToPixel</code> function that implicitly uses the current view. It is equivalent to: </p><div class="fragment"><div class="line">target.mapCoordsToPixel(point, target.getView());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in target coordinates (pixels)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#a5ce02e4fd30e065c4dbeec239ae579b3" title="Convert a point from target coordinates to world coordinates, using the current view.">mapPixelToCoords</a></code> </dd></dl>

</div>
</div>
<a id="a07a8da6e2a9e3ce5f36344e3d8e7c41a" name="a07a8da6e2a9e3ce5f36344e3d8e7c41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a8da6e2a9e3ce5f36344e3d8e7c41a">&#9670;&#160;</a></span>mapCoordsToPixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a> sf::RenderTarget::mapCoordsToPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from world coordinates to target coordinates. </p>
<p>This function finds the pixel of the render target that matches the given 2D point. In other words, it goes through the same process as the graphics card, to compute the final position of a rendered point.</p>
<p>Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not <code>true</code> anymore, i.e. a point located at (150, 75) in your 2D world may map to the pixel (10, 50) of your render target &ndash; if the view is translated by (140, 25).</p>
<p>This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to convert </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in target coordinates (pixels)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#a5ce02e4fd30e065c4dbeec239ae579b3" title="Convert a point from target coordinates to world coordinates, using the current view.">mapPixelToCoords</a></code> </dd></dl>

</div>
</div>
<a id="a5ce02e4fd30e065c4dbeec239ae579b3" name="a5ce02e4fd30e065c4dbeec239ae579b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce02e4fd30e065c4dbeec239ae579b3">&#9670;&#160;</a></span>mapPixelToCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> sf::RenderTarget::mapPixelToCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from target coordinates to world coordinates, using the current view. </p>
<p>This function is an overload of the mapPixelToCoords function that implicitly uses the current view. It is equivalent to: </p><div class="fragment"><div class="line">target.mapPixelToCoords(point, target.getView());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Pixel to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in "world" coordinates</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#ab473e0723ba16cf913deb03774c8458c" title="Convert a point from world coordinates to target coordinates, using the current view.">mapCoordsToPixel</a></code> </dd></dl>

</div>
</div>
<a id="af7c5ec0787ffdcabfcee0f2b88dd4536" name="af7c5ec0787ffdcabfcee0f2b88dd4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c5ec0787ffdcabfcee0f2b88dd4536">&#9670;&#160;</a></span>mapPixelToCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesf.html#af14b40e82368dd601a7ef8037214804d">Vector2f</a> sf::RenderTarget::mapPixelToCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a point from target coordinates to world coordinates. </p>
<p>This function finds the 2D position that matches the given pixel of the render target. In other words, it does the inverse of what the graphics card does, to find the initial position of a rendered pixel.</p>
<p>Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not <code>true</code> anymore, i.e. a point located at (10, 50) in your render target may map to the point (150, 75) in your 2D world &ndash; if the view is translated by (140, 25).</p>
<p>For render-windows, this function is typically used to find which point (or object) is located below the mouse cursor.</p>
<p>This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Pixel to convert </td></tr>
    <tr><td class="paramname">view</td><td>The view to use for converting the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted point, in "world" units</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#ab473e0723ba16cf913deb03774c8458c" title="Convert a point from world coordinates to target coordinates, using the current view.">mapCoordsToPixel</a></code> </dd></dl>

</div>
</div>
<a id="aab231189dcb7d529d7d535772ac5ab01" name="aab231189dcb7d529d7d535772ac5ab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab231189dcb7d529d7d535772ac5ab01">&#9670;&#160;</a></span>onCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderWindow::onCreate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called after the window has been created. </p>
<p>This function is called so that derived classes can perform their own specific initialization as soon as the window is created. </p>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a3397a7265f654be7ce9ccde3a53a39df">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a5223392a3ebd6581bd7b2c5e211ba072" name="a5223392a3ebd6581bd7b2c5e211ba072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5223392a3ebd6581bd7b2c5e211ba072">&#9670;&#160;</a></span>onResize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderWindow::onResize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called after the window has been resized. </p>
<p>This function is called so that derived classes can perform custom actions when the size of the window changes. </p>

<p>Reimplemented from <a class="el" href="classsf_1_1WindowBase.html#a8be41815cbeb89bc49e8752b62283192">sf::WindowBase</a>.</p>

</div>
</div>
<a id="a6090926b477e9d0a83854b94b9e1fd35" name="a6090926b477e9d0a83854b94b9e1fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6090926b477e9d0a83854b94b9e1fd35">&#9670;&#160;</a></span>pollEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt; sf::WindowBase::pollEvent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop the next event from the front of the FIFO event queue, if any, and return it. </p>
<p>This function is not blocking: if there's no pending event then it will return a <code>std::nullopt</code>. Note that more than one event may be present in the event queue, thus you should always call this function in a loop to make sure that you process every pending event. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.pollEvent())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// process event...</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The event, otherwise <code>std::nullopt</code> if no events are pending</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#ab5975f6f6a06ecd6c18fa0f62cd1edf7" title="Wait for an event and return it.">waitEvent</a></code>, <code><a class="el" href="classsf_1_1WindowBase.html#ad86ae79ff4e2da25af1ca3cd06f79557" title="Handle all pending events.">handleEvents</a></code> </dd></dl>

</div>
</div>
<a id="ad5a98401113df931ddcd54c080f7aa8e" name="ad5a98401113df931ddcd54c080f7aa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a98401113df931ddcd54c080f7aa8e">&#9670;&#160;</a></span>popGLStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::popGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore the previously saved OpenGL render states and matrices. </p>
<p>See the description of <code>pushGLStates</code> to get a detailed description of these functions.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7" title="Save the current OpenGL render states and matrices.">pushGLStates</a></code> </dd></dl>

</div>
</div>
<a id="a8d1998464ccc54e789aaf990242b47f7" name="a8d1998464ccc54e789aaf990242b47f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1998464ccc54e789aaf990242b47f7">&#9670;&#160;</a></span>pushGLStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::pushGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save the current OpenGL render states and matrices. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with popGLStates, it ensures that: </p><ul>
<li>SFML's internal states are not messed up by your OpenGL code </li>
<li>your OpenGL states are not modified by a call to a SFML function</li>
</ul>
<p>More specifically, it must be used around code that calls <code>draw</code> functions. Example: </p><div class="fragment"><div class="line"><span class="comment">// OpenGL code here...</span></div>
<div class="line">window.pushGLStates();</div>
<div class="line">window.draw(...);</div>
<div class="line">window.draw(...);</div>
<div class="line">window.popGLStates();</div>
<div class="line"><span class="comment">// OpenGL code here...</span></div>
</div><!-- fragment --><p>Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the resetGLStates function if you do so.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e" title="Restore the previously saved OpenGL render states and matrices.">popGLStates</a></code> </dd></dl>

</div>
</div>
<a id="a448770d2372d8df0a1ad6b1c7cce3c89" name="a448770d2372d8df0a1ad6b1c7cce3c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448770d2372d8df0a1ad6b1c7cce3c89">&#9670;&#160;</a></span>requestFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::requestFocus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the current window to be made the active foreground window. </p>
<p>At any given time, only one window may have the input focus to receive input events such as keystrokes or mouse events. If a window requests focus, it only hints to the operating system, that it would like to be focused. The operating system is free to deny the request. This is not to be confused with <code><a class="el" href="#a3f5476821139d5a7f0e4df19dab69b56" title="Activate or deactivate the window as the current target for OpenGL rendering.">setActive()</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#ad87bd19e979c426cb819ccde8c95232e" title="Check whether the window has the input focus.">hasFocus</a></code> </dd></dl>

</div>
</div>
<a id="aac7504990d27dada4bfe3c7866920765" name="aac7504990d27dada4bfe3c7866920765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7504990d27dada4bfe3c7866920765">&#9670;&#160;</a></span>resetGLStates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::resetGLStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the internal OpenGL states so that the target is ready for drawing. </p>
<p>This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use <code>pushGLStates</code>/<code>popGLStates</code>. It makes sure that all OpenGL states needed by SFML are set, so that subsequent <code><a class="el" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39" title="Draw a drawable object to the render target.">draw()</a></code> calls will work as expected.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// OpenGL code here...</span></div>
<div class="line">glPushAttrib(...);</div>
<div class="line">window.resetGLStates();</div>
<div class="line">window.draw(...);</div>
<div class="line">window.draw(...);</div>
<div class="line">glPopAttrib(...);</div>
<div class="line"><span class="comment">// OpenGL code here...</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3f5476821139d5a7f0e4df19dab69b56" name="a3f5476821139d5a7f0e4df19dab69b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5476821139d5a7f0e4df19dab69b56">&#9670;&#160;</a></span>setActive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderWindow::setActive </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate or deactivate the window as the current target for OpenGL rendering. </p>
<p>A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with <code><a class="el" href="classsf_1_1WindowBase.html#a448770d2372d8df0a1ad6b1c7cce3c89" title="Request the current window to be made the active foreground window.">requestFocus()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td><code>true</code> to activate, <code>false</code> to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if operation was successful, <code>false</code> otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="classsf_1_1RenderTarget.html#adc225ead22a70843ffa9b7eebefa0ce1">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="aaab549da64cedf74fa6f1ae7a3cc79e0" name="aaab549da64cedf74fa6f1ae7a3cc79e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab549da64cedf74fa6f1ae7a3cc79e0">&#9670;&#160;</a></span>setActive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Window::setActive </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>active</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate or deactivate the window as the current target for OpenGL rendering. </p>
<p>A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with <code><a class="el" href="classsf_1_1WindowBase.html#a448770d2372d8df0a1ad6b1c7cce3c89" title="Request the current window to be made the active foreground window.">requestFocus()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td><code>true</code> to activate, <code>false</code> to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if operation was successful, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="af4322d315baf93405bf0d5087ad5e784" name="af4322d315baf93405bf0d5087ad5e784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4322d315baf93405bf0d5087ad5e784">&#9670;&#160;</a></span>setFramerateLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::setFramerateLimit </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Limit the framerate to a maximum fixed frequency. </p>
<p>If a limit is set, the window will use a small delay after each call to <code><a class="el" href="classsf_1_1Window.html#adabf839cb103ac96cfc82f781638772a" title="Display on screen what has been rendered to the window so far.">display()</a></code> to ensure that the current frame lasted long enough to match the framerate limit. SFML will try to match the given limit as much as it can, but since it internally uses <code><a class="el" href="group__system.html#gab8c0d1f966b4e5110fd370b662d8c11b" title="Make the current thread sleep for a given duration.">sf::sleep</a></code>, whose precision depends on the underlying OS, the results may be a little imprecise as well (for example, you can get 65 FPS when requesting 60).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>Framerate limit, in frames per seconds (use 0 to disable limit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba4d2434d6c2d058485d8a35b10afb25" name="aba4d2434d6c2d058485d8a35b10afb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4d2434d6c2d058485d8a35b10afb25">&#9670;&#160;</a></span>setIcon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderWindow::setIcon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Image.html">Image</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>icon</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the window's icon. </p>
<p>The OS default icon is used by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">icon</td><td><a class="el" href="classsf_1_1Image.html" title="Class for loading, manipulating and saving images.">Image</a> to use as the icon. The image is copied, so you need not keep the source alive after calling this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07ab1f9f9dc2312ad0ee83d1ffee9715" name="a07ab1f9f9dc2312ad0ee83d1ffee9715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ab1f9f9dc2312ad0ee83d1ffee9715">&#9670;&#160;</a></span>setIcon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setIcon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *</td>          <td class="paramname"><span class="paramname"><em>pixels</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the window's icon. </p>
<p><code>pixels</code> must be an array of <code>size</code> pixels in 32-bits RGBA format.</p>
<p>The OS default icon is used by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Icon's width and height, in pixels </td></tr>
    <tr><td class="paramname">pixels</td><td>Pointer to the array of pixels in memory. The pixels are copied, so you need not keep the source alive after calling this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#accd36ae6244ae1e6d643f6c109e983f8" title="Change the title of the window.">setTitle</a></code> </dd></dl>

</div>
</div>
<a id="ad37f939b492c7ea046d4f7b45ac46df1" name="ad37f939b492c7ea046d4f7b45ac46df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37f939b492c7ea046d4f7b45ac46df1">&#9670;&#160;</a></span>setJoystickThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setJoystickThreshold </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the joystick threshold. </p>
<p>The joystick threshold is the value below which no JoystickMoved event will be generated.</p>
<p>The threshold value is 0.1 by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>New threshold, in the range [0, 100] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd1199a64d459ba531deb65f093050a6" name="afd1199a64d459ba531deb65f093050a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1199a64d459ba531deb65f093050a6">&#9670;&#160;</a></span>setKeyRepeatEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setKeyRepeatEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable automatic key-repeat. </p>
<p>If key repeat is enabled, you will receive repeated KeyPressed events while keeping a key pressed. If it is disabled, you will only get a single event when the key is pressed.</p>
<p>Key repeat is enabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable, <code>false</code> to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65f856835295a85a2959c962a1616cad" name="a65f856835295a85a2959c962a1616cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f856835295a85a2959c962a1616cad">&#9670;&#160;</a></span>setMaximumSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMaximumSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>maximumSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum window rendering region size. </p>
<p>Pass <code>std::nullopt</code> to unset the maximum size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumSize</td><td>New maximum size, in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a742a8f386668f58fe27c0b5f5929de7e" name="a742a8f386668f58fe27c0b5f5929de7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742a8f386668f58fe27c0b5f5929de7e">&#9670;&#160;</a></span>setMinimumSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMinimumSize </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>minimumSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimum window rendering region size. </p>
<p>Pass <code>std::nullopt</code> to unset the minimum size</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimumSize</td><td>New minimum size, in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07487a3c7e04472b19e96d3a602213ec" name="a07487a3c7e04472b19e96d3a602213ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07487a3c7e04472b19e96d3a602213ec">&#9670;&#160;</a></span>setMouseCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Cursor.html">Cursor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cursor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the displayed cursor to a native system cursor. </p>
<p>Upon window creation, the arrow cursor is used by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>The cursor must not be destroyed while in use by the window.</dd>
<dd>
Features related to <a class="el" href="classsf_1_1Cursor.html" title="Cursor defines the appearance of a system cursor.">Cursor</a> are not supported on iOS and Android.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>Native system cursor type to display</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1Cursor.html#a3385d2f53bc5b3b296f0409f79a57116" title="Create a native system cursor.">sf::Cursor::createFromSystem</a></code>, <code><a class="el" href="classsf_1_1Cursor.html#a93aa2dfcc8c4f27513c6632153521fa7" title="Create a cursor with the provided image.">sf::Cursor::createFromPixels</a></code> </dd></dl>

</div>
</div>
<a id="a0023344922a1e854175c8ca22b072020" name="a0023344922a1e854175c8ca22b072020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0023344922a1e854175c8ca22b072020">&#9670;&#160;</a></span>setMouseCursorGrabbed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursorGrabbed </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>grabbed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grab or release the mouse cursor. </p>
<p>If set, grabs the mouse cursor inside this window's client area so it may no longer be moved outside its bounds. Note that grabbing is only active while the window has focus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grabbed</td><td><code>true</code> to enable, <code>false</code> to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa4a3372b2870294d1579d8621fe3c1a" name="afa4a3372b2870294d1579d8621fe3c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4a3372b2870294d1579d8621fe3c1a">&#9670;&#160;</a></span>setMouseCursorVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setMouseCursorVisible </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visible</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Show or hide the mouse cursor. </p>
<p>The mouse cursor is visible by default.</p>
<dl class="section warning"><dt>Warning</dt><dd>On Windows, this function needs to be called from the thread that created the window.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td><code>true</code> to show the mouse cursor, <code>false</code> to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7282bbf43820f20f41c704c2ab5b86f8" name="a7282bbf43820f20f41c704c2ab5b86f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7282bbf43820f20f41c704c2ab5b86f8">&#9670;&#160;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#af0ffe1b157a56931ee3a9a1a771a827a">Vector2i</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the position of the window on screen. </p>
<p>This function only works for top-level windows (i.e. it will be ignored for windows created from the handle of a child window/control).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>New position, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#a5ddaa5943f547645079f081422e45c81" title="Get the position of the window.">getPosition</a></code> </dd></dl>

</div>
</div>
<a id="abd2581f59f35bd379307ea5b6254631c" name="abd2581f59f35bd379307ea5b6254631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2581f59f35bd379307ea5b6254631c">&#9670;&#160;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesf.html#adc674b5f5c13a6734954a18e01a73b42">Vector2u</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of the rendering region of the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>New size, in pixels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#af5d9a6263e05fd4ed4b31a5c202cc642" title="Get the size of the rendering region of the window.">getSize</a></code> </dd></dl>

</div>
</div>
<a id="accd36ae6244ae1e6d643f6c109e983f8" name="accd36ae6244ae1e6d643f6c109e983f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd36ae6244ae1e6d643f6c109e983f8">&#9670;&#160;</a></span>setTitle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setTitle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1String.html">String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>title</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the title of the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>New title</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="#aba4d2434d6c2d058485d8a35b10afb25" title="Change the window&#39;s icon.">setIcon</a></code> </dd></dl>

</div>
</div>
<a id="a59041c4556e0351048f8aff366034f61" name="a59041c4556e0351048f8aff366034f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59041c4556e0351048f8aff366034f61">&#9670;&#160;</a></span>setVerticalSyncEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Window::setVerticalSyncEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable vertical synchronization. </p>
<p>Activating vertical synchronization will limit the number of frames displayed to the refresh rate of the monitor. This can avoid some visual artifacts, and limit the framerate to a good value (but not constant across different computers).</p>
<p>Vertical synchronization is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable v-sync, <code>false</code> to deactivate it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063db6dd0a14913504af30e50cb6d946" name="a063db6dd0a14913504af30e50cb6d946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063db6dd0a14913504af30e50cb6d946">&#9670;&#160;</a></span>setView()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTarget::setView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1View.html">View</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>view</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the current active view. </p>
<p>The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of <code><a class="el" href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView()</a></code> to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>New view to use</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1RenderTarget.html#adbf8dc5a1f4abbe15a3fbb915844c7ea" title="Get the view currently in use in the render target.">getView</a></code>, <code><a class="el" href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c" title="Get the default view of the render target.">getDefaultView</a></code> </dd></dl>

</div>
</div>
<a id="a576488ad202cb2cd4359af94eaba4dd8" name="a576488ad202cb2cd4359af94eaba4dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576488ad202cb2cd4359af94eaba4dd8">&#9670;&#160;</a></span>setVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sf::WindowBase::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visible</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Show or hide the window. </p>
<p>The window is shown by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td><code>true</code> to show the window, <code>false</code> to hide it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5975f6f6a06ecd6c18fa0f62cd1edf7" name="ab5975f6f6a06ecd6c18fa0f62cd1edf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5975f6f6a06ecd6c18fa0f62cd1edf7">&#9670;&#160;</a></span>waitEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classsf_1_1Event.html">Event</a> &gt; sf::WindowBase::waitEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1Time.html">Time</a></td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0">Time::Zero</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for an event and return it. </p>
<p>This function is blocking: if there's no pending event then it will wait until an event is received or until the provided timeout elapses. Only if an error or a timeout occurs the returned event will be <code>std::nullopt</code>. This function is typically used when you have a thread that is dedicated to events handling: you want to make this thread sleep as long as no new event is received. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">const</span> std::optional event = window.waitEvent())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// process event...</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum time to wait (<code><a class="el" href="classsf_1_1Time.html#a8db127b632fa8da21550e7282af11fa0" title="Predefined &quot;zero&quot; time value.">Time::Zero</a></code> for infinite)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event, otherwise <code>std::nullopt</code> on timeout or if window was closed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classsf_1_1WindowBase.html#a6090926b477e9d0a83854b94b9e1fd35" title="Pop the next event from the front of the FIFO event queue, if any, and return it.">pollEvent</a></code>, <code><a class="el" href="classsf_1_1WindowBase.html#ad86ae79ff4e2da25af1ca3cd06f79557" title="Handle all pending events.">handleEvents</a></code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RenderWindow_8hpp_source.html">RenderWindow.hpp</a></li>
</ul>
</div><!-- contents -->

                        </div>
                    </div>
                </div>
                <button type="button" class="md-top md-icon" data-md-component="top" hidden>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z" /></svg>
                    Back to top
                </button>
            </main>
            <footer class="md-footer">
                <div class="md-footer-meta md-typeset">
                    <div class="md-footer-meta__inner md-grid">
                        <div class="md-copyright">
                            <div class="md-copyright__highlight">Copyright &copy; <a href="mailto:laurent@sfml-dev.org">Laurent Gomila</a></div>
                        </div>
                        <div class="md-social">
                            <a href="https://fosstodon.org/@sfml" target="_blank" rel="noopener me" title="SFML on Fosstodon" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.5 102.5 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5m-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"
                                    />
                                </svg>
                            </a>
                            <a href="https://twitter.com/sfmldev" target="_blank" rel="noopener" title="SFML on Twitter" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253"
                                    />
                                </svg>
                            </a>
                            <a href="https://bsky.app/profile/sfml.bsky.social" target="_blank" rel="noopener" title="SFML on Bluesky" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3M288 227.1c-26.1-50.7-97.1-145.2-163.1-191.8C61.6-9.4 37.5-1.7 21.6 5.5 3.3 13.8 0 41.9 0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7 3.3-.5 6.6-.9 10-1.4-3.3.5-6.6 1-10 1.4-93.9 14-177.3 48.2-67.9 169.9C220.6 589.1 265.1 437.8 288 361.1c22.9 76.7 49.2 222.5 185.6 103.4 102.4-103.4 28.1-156-65.8-169.9-3.3-.4-6.7-.8-10-1.3 3.4.4 6.7.9 10 1.3 64.1 7.1 133.6-15.1 153.2-80.7C566.9 194 576 75 576 58.4s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8C385.1 81.9 314.1 176.4 288 227.1"
                                    ></path>
                                </svg>
                            </a>
                            <a href="https://discord.gg/nr4X7Fh" target="_blank" rel="noopener" title="SFML&#39;s Discord Server" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M524.531 69.836a1.5 1.5 0 0 0-.764-.7A485 485 0 0 0 404.081 32.03a1.82 1.82 0 0 0-1.923.91 338 338 0 0 0-14.9 30.6 447.9 447.9 0 0 0-134.426 0 310 310 0 0 0-15.135-30.6 1.89 1.89 0 0 0-1.924-.91 483.7 483.7 0 0 0-119.688 37.107 1.7 1.7 0 0 0-.788.676C39.068 183.651 18.186 294.69 28.43 404.354a2.02 2.02 0 0 0 .765 1.375 487.7 487.7 0 0 0 146.825 74.189 1.9 1.9 0 0 0 2.063-.676A348 348 0 0 0 208.12 430.4a1.86 1.86 0 0 0-1.019-2.588 321 321 0 0 1-45.868-21.853 1.885 1.885 0 0 1-.185-3.126 251 251 0 0 0 9.109-7.137 1.82 1.82 0 0 1 1.9-.256c96.229 43.917 200.41 43.917 295.5 0a1.81 1.81 0 0 1 1.924.233 235 235 0 0 0 9.132 7.16 1.884 1.884 0 0 1-.162 3.126 301.4 301.4 0 0 1-45.89 21.83 1.875 1.875 0 0 0-1 2.611 391 391 0 0 0 30.014 48.815 1.86 1.86 0 0 0 2.063.7A486 486 0 0 0 610.7 405.729a1.88 1.88 0 0 0 .765-1.352c12.264-126.783-20.532-236.912-86.934-334.541M222.491 337.58c-28.972 0-52.844-26.587-52.844-59.239s23.409-59.241 52.844-59.241c29.665 0 53.306 26.82 52.843 59.239 0 32.654-23.41 59.241-52.843 59.241m195.38 0c-28.971 0-52.843-26.587-52.843-59.239s23.409-59.241 52.843-59.241c29.667 0 53.307 26.82 52.844 59.239 0 32.654-23.177 59.241-52.844 59.241"
                                    />
                                </svg>
                            </a>
                        </div>
                    </div>
                </div>
            </footer>
        </div>
        <div class="md-dialog" data-md-component="dialog">
            <div class="md-dialog__inner md-typeset"></div>
        </div>
        <script id="__config" type="application/json">
            {
                "base": "../..",
                "features": ["content.code.copy", "navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.prune", "navigation.path", "navigation.indexes", "navigation.top", "navigation.footer", "toc.follow", "search.suggest"],
                "search": "../../assets/javascripts/workers/search.6ce7567c.min.js",
                "translations": {
                    "clipboard.copied": "Copied to clipboard",
                    "clipboard.copy": "Copy to clipboard",
                    "search.result.more.one": "1 more on this page",
                    "search.result.more.other": "# more on this page",
                    "search.result.none": "No matching documents",
                    "search.result.one": "1 matching document",
                    "search.result.other": "# matching documents",
                    "search.result.placeholder": "Type to start searching",
                    "search.result.term.missing": "Missing",
                    "select.version": "Select version"
                }
            }
        </script>
        <script src="../../assets/javascripts/bundle.88dd0f4e.min.js"></script>
    </body>
</html>

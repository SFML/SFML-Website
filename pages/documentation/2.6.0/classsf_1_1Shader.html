<!DOCTYPE html>
<html lang="en" class="no-js">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <meta name="description" content="Simple and Fast Multimedia Library" />
        <link rel="canonical" href="https://www.sfml-dev.org/" />
        <link rel="next" href="/learn/" />
        <link rel="icon" href="/images/favicon.ico" />
        <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.30" />
        <title>Home - Simple and Fast Multimedia Library</title>
        <link rel="stylesheet" href="/assets/stylesheets/main.3cba04c6.min.css" />
        <link rel="stylesheet" href="/assets/stylesheets/palette.06af60db.min.css" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback" />
        <style>
            :root {
                --md-text-font: "Ubuntu";
                --md-code-font: "Roboto Mono";
            }
        </style>
        <link rel="stylesheet" href="/styles/extra.css" />
        <script>
            (__md_scope = new URL(".", location)),
                (__md_hash = (e) => [...e].reduce((e, _) => (e << 5) - e + _.charCodeAt(0), 0)),
                (__md_get = (e, _ = localStorage, t = __md_scope) => JSON.parse(_.getItem(t.pathname + "." + e))),
                (__md_set = (e, _, t = localStorage, a = __md_scope) => {
                    try {
                        t.setItem(a.pathname + "." + e, JSON.stringify(_));
                    } catch (e) {}
                });
        </script>
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
        <script type="text/javascript" src="clipboard.js"></script>
        <script type="text/javascript" src="cookie.js"></script>
        <script type="text/javascript" src="resize.js"></script>
        <link rel="stylesheet" type="text/css" href="search/search.css" />
        <link rel="stylesheet" type="text/css" href="searchOverrides.css" />
        <script type="text/javascript" src="search/searchdata.js"></script>
        <script type="text/javascript" src="search/search.js"></script>
        <script type="text/javascript">
            /* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
            $(document).ready(function () {
                init_search();
            });
            /* @license-end */
        </script>
    </head>
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
        <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off" />
        <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off" />
        <label class="md-overlay" for="__drawer"></label>
        <div data-md-component="skip">
            <a href="#simple-and-fast-multimedia-library" class="md-skip"> Skip to content </a>
        </div>
        <div data-md-component="announce"></div>
        <header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
            <nav class="md-header__inner md-grid" aria-label="Header">
                <a href="." title="Simple and Fast Multimedia Library" class="md-header__button md-logo" aria-label="Simple and Fast Multimedia Library" data-md-component="logo">
                    <img src="/images/logo.png" alt="logo" />
                </a>
                <label class="md-header__button md-icon" for="__drawer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z" /></svg>
                </label>
                <div class="md-header__title" data-md-component="header-title">
                    <div class="md-header__ellipsis">
                        <div class="md-header__topic">
                            <span class="md-ellipsis"> Simple and Fast Multimedia Library </span>
                        </div>
                        <div class="md-header__topic" data-md-component="header-topic">
                            <span class="md-ellipsis"> Home </span>
                        </div>
                    </div>
                </div>
                <form class="md-header__option" data-md-component="palette">
                    <input
                        class="md-option"
                        data-md-color-media="(prefers-color-scheme: light)"
                        data-md-color-scheme="default"
                        data-md-color-primary="light-green"
                        data-md-color-accent="indigo"
                        aria-label="Switch to dark mode"
                        type="radio"
                        name="__palette"
                        id="__palette_0"
                    />
                    <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path
                                d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"
                            />
                        </svg>
                    </label>
                    <input
                        class="md-option"
                        data-md-color-media="(prefers-color-scheme: dark)"
                        data-md-color-scheme="slate"
                        data-md-color-primary="green"
                        data-md-color-accent="indigo"
                        aria-label="Switch to light mode"
                        type="radio"
                        name="__palette"
                        id="__palette_1"
                    />
                    <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path
                                d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"
                            />
                        </svg>
                    </label>
                </form>
                <script>
                    var media,
                        input,
                        key,
                        value,
                        palette = __md_get("__palette");
                    if (palette && palette.color) {
                        "(prefers-color-scheme)" === palette.color.media &&
                            ((media = matchMedia("(prefers-color-scheme: light)")),
                            (input = document.querySelector(media.matches ? "[data-md-color-media='(prefers-color-scheme: light)']" : "[data-md-color-media='(prefers-color-scheme: dark)']")),
                            (palette.color.media = input.getAttribute("data-md-color-media")),
                            (palette.color.scheme = input.getAttribute("data-md-color-scheme")),
                            (palette.color.primary = input.getAttribute("data-md-color-primary")),
                            (palette.color.accent = input.getAttribute("data-md-color-accent")));
                        for ([key, value] of Object.entries(palette.color)) document.body.setAttribute("data-md-color-" + key, value);
                    }
                </script>
                <div class="md-header__option">
                    <div class="md-select">
                        <button class="md-header__button md-icon" aria-label="Select language">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                <path
                                    d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"
                                />
                            </svg>
                        </button>
                        <div class="md-select__inner">
                            <ul class="md-select__list">
                                <li class="md-select__item">
                                    <a href="/" hreflang="en" class="md-select__link"> English </a>
                                </li>
                                <li class="md-select__item">
                                    <a href="/fr/" hreflang="fr" class="md-select__link"> Fran√ßais </a>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
                <label class="md-header__button md-icon" for="__search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path
                            d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"
                        />
                    </svg>
                </label>
                <div class="md-search" data-md-component="search" role="dialog">
                    <label class="md-search__overlay" for="__search"></label>
                    <div class="md-search__inner" role="search">
                        <form class="md-search__form" name="search">
                            <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required />
                            <label class="md-search__icon md-icon" for="__search">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                                    <path
                                        d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"
                                    />
                                </svg>
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z" /></svg>
                            </label>
                            <nav class="md-search__options" aria-label="Search">
                                <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z" /></svg>
                                </button>
                            </nav>
                            <div class="md-search__suggest" data-md-component="search-suggest"></div>
                        </form>
                        <div class="md-search__output">
                            <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
                                <div class="md-search-result" data-md-component="search-result">
                                    <div class="md-search-result__meta">Initializing search</div>
                                    <ol class="md-search-result__list" role="presentation"></ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="md-header__source">
                    <a href="https://github.com/SFML/SFML" title="Go to repository" class="md-source" data-md-component="source">
                        <div class="md-source__icon md-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
                                <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. -->
                                <path
                                    d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"
                                />
                            </svg>
                        </div>
                        <div class="md-source__repository">SFML</div>
                    </a>
                </div>
            </nav>
            <nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
                <div class="md-grid">
                    <ul class="md-tabs__list">
                        <li class="md-tabs__item">
                            <a href="/" class="md-tabs__link"> Home </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="/learn/" class="md-tabs__link"> Learn </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="/tutorials/2.6/" class="md-tabs__link"> Tutorials </a>
                        </li>
                        <li class="md-tabs__item md-tabs__item--active">
                            <a href="/documentation" class="md-tabs__link"> Documentation </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="/download/" class="md-tabs__link"> Download </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="/community/" class="md-tabs__link"> Community </a>
                        </li>
                        <li class="md-tabs__item">
                            <a href="/development/" class="md-tabs__link"> Development </a>
                        </li>
                    </ul>
                </div>
            </nav>
        </header>
        <div class="md-container" data-md-component="container">
            <main class="md-main" data-md-component="main">
                <div class="md-main__inner md-grid">
                    <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" hidden>
                        <div class="md-sidebar__scrollwrap">
                            <div class="md-sidebar__inner">
                                <nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
                                    <label class="md-nav__title" for="__drawer">
                                        <a href="." title="Simple and Fast Multimedia Library" class="md-nav__button md-logo" aria-label="Simple and Fast Multimedia Library" data-md-component="logo">
                                            <img src="/images/logo.png" alt="logo" />
                                        </a>
                                        Simple and Fast Multimedia Library
                                    </label>
                                    <div class="md-nav__source">
                                        <a href="https://github.com/SFML/SFML" title="Go to repository" class="md-source" data-md-component="source">
                                            <div class="md-source__icon md-icon">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
                                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. -->
                                                    <path
                                                        d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"
                                                    />
                                                </svg>
                                            </div>
                                            <div class="md-source__repository">SFML</div>
                                        </a>
                                    </div>
                                    <ul class="md-nav__list" data-md-scrollfix>
                                        <li class="md-nav__item">
                                            <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc" />
                                            <label class="md-nav__link" for="__toc">
                                                <span class="md-ellipsis"> Home </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </label>
                                            <a href="." class="md-nav__link">
                                                <span class="md-ellipsis"> Home </span>
                                            </a>
                                            <nav class="md-nav md-nav--secondary" aria-label="Table of contents">
                                                <label class="md-nav__title" for="__toc">
                                                    <span class="md-nav__icon md-icon"></span>
                                                    Table of contents
                                                </label>
                                                <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
                                                    <li class="md-nav__item">
                                                        <a href="#sfml-is-multi-media" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML is multi-media </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="#sfml-is-multi-platform" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML is multi-platform </span>
                                                        </a>
                                                    </li>
                                                    <li class="md-nav__item">
                                                        <a href="#sfml-is-multi-language" class="md-nav__link">
                                                            <span class="md-ellipsis"> SFML is multi-language </span>
                                                        </a>
                                                    </li>
                                                </ul>
                                            </nav>
                                        </li>
                                        <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
                                            <a href="learn/" class="md-nav__link">
                                                <span class="md-ellipsis"> Learn </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
                                            <a href="tutorials/2.6/" class="md-nav__link">
                                                <span class="md-ellipsis"> Tutorials </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--active">
                                            <a href="documentation" class="md-nav__link md-nav__link--active">
                                                <span class="md-ellipsis"> Documentation </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
                                            <a href="download/" class="md-nav__link">
                                                <span class="md-ellipsis"> Download </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="community/" class="md-nav__link">
                                                <span class="md-ellipsis"> Community </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
                                            <a href="development/" class="md-nav__link">
                                                <span class="md-ellipsis"> Development </span>
                                                <span class="md-nav__icon md-icon"></span>
                                            </a>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </div>
                    <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" hidden>
                        <div class="md-sidebar__scrollwrap">
                            <div class="md-sidebar__inner">
                                <nav class="md-nav md-nav--secondary" aria-label="Table of contents">
                                    <label class="md-nav__title" for="__toc">
                                        <span class="md-nav__icon md-icon"></span>
                                        Table of contents
                                    </label>
                                    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
                                        <li class="md-nav__item">
                                            <a href="#sfml-is-multi-media" class="md-nav__link">
                                                <span class="md-ellipsis"> SFML is multi-media </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="#sfml-is-multi-platform" class="md-nav__link">
                                                <span class="md-ellipsis"> SFML is multi-platform </span>
                                            </a>
                                        </li>
                                        <li class="md-nav__item">
                                            <a href="#sfml-is-multi-language" class="md-nav__link">
                                                <span class="md-ellipsis"> SFML is multi-language </span>
                                            </a>
                                        </li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </div>
                    <div class="md-content" data-md-component="content">
                        <div class="contents">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="topics.html"><span>Topics</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1Shader.html">Shader</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classsf_1_1Shader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sf::Shader Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">Shader</a> class (vertex, geometry and fragment)  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Shader_8hpp_source.html">SFML/Graphics/Shader.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::Shader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsf_1_1Shader.png" usemap="#sf::Shader_map" alt=""/>
  <map id="sf::Shader_map" name="sf::Shader_map">
<area href="classsf_1_1GlResource.html" title="Base class for classes that require an OpenGL context." alt="sf::GlResource" shape="rect" coords="0,0,105,24"/>
<area href="classsf_1_1NonCopyable.html" title="Utility class that makes any derived class non-copyable." alt="sf::NonCopyable" shape="rect" coords="115,0,220,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special type that can be passed to <a class="el" href="#abf78e3bea1e9b0bab850b6b0a0de29c7" title="Specify value for float uniform.">setUniform()</a>, and that represents the texture of the object being drawn.  <a href="structsf_1_1Shader_1_1CurrentTextureType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afaa1aa65e5de37b74d047da9def9f9b3" id="r_afaa1aa65e5de37b74d047da9def9f9b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> { <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce">Vertex</a>
, <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3a812421100fd57456727375938fb62788">Geometry</a>
, <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a">Fragment</a>
 }</td></tr>
<tr class="memdesc:afaa1aa65e5de37b74d047da9def9f9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of shaders.  <a href="#afaa1aa65e5de37b74d047da9def9f9b3">More...</a><br /></td></tr>
<tr class="separator:afaa1aa65e5de37b74d047da9def9f9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d7f28f26b4122959fcafec871c2c3c5" id="r_a1d7f28f26b4122959fcafec871c2c3c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d7f28f26b4122959fcafec871c2c3c5">Shader</a> ()</td></tr>
<tr class="memdesc:a1d7f28f26b4122959fcafec871c2c3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a1d7f28f26b4122959fcafec871c2c3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bac6cc8b046ecd8fb967c145a2380e6" id="r_a4bac6cc8b046ecd8fb967c145a2380e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bac6cc8b046ecd8fb967c145a2380e6">~Shader</a> ()</td></tr>
<tr class="memdesc:a4bac6cc8b046ecd8fb967c145a2380e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a4bac6cc8b046ecd8fb967c145a2380e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053a5632848ebaca2fcd8ba29abe9e6e" id="r_a053a5632848ebaca2fcd8ba29abe9e6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e">loadFromFile</a> (const std::string &amp;filename, <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr class="memdesc:a053a5632848ebaca2fcd8ba29abe9e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry or fragment shader from a file.  <br /></td></tr>
<tr class="separator:a053a5632848ebaca2fcd8ba29abe9e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d7289966fcef562eeb92271c03e3dc" id="r_ac9d7289966fcef562eeb92271c03e3dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d7289966fcef562eeb92271c03e3dc">loadFromFile</a> (const std::string &amp;vertexShaderFilename, const std::string &amp;fragmentShaderFilename)</td></tr>
<tr class="memdesc:ac9d7289966fcef562eeb92271c03e3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from files.  <br /></td></tr>
<tr class="separator:ac9d7289966fcef562eeb92271c03e3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295d8468811ca15bf9c5401a7a7d4f54" id="r_a295d8468811ca15bf9c5401a7a7d4f54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a295d8468811ca15bf9c5401a7a7d4f54">loadFromFile</a> (const std::string &amp;vertexShaderFilename, const std::string &amp;geometryShaderFilename, const std::string &amp;fragmentShaderFilename)</td></tr>
<tr class="memdesc:a295d8468811ca15bf9c5401a7a7d4f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry and fragment shaders from files.  <br /></td></tr>
<tr class="separator:a295d8468811ca15bf9c5401a7a7d4f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d46bf71dff2d791117e4e472148aa" id="r_ac92d46bf71dff2d791117e4e472148aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92d46bf71dff2d791117e4e472148aa">loadFromMemory</a> (const std::string &amp;shader, <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr class="memdesc:ac92d46bf71dff2d791117e4e472148aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry or fragment shader from a source code in memory.  <br /></td></tr>
<tr class="separator:ac92d46bf71dff2d791117e4e472148aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34e94070d7547a890166b7993658a9b" id="r_ae34e94070d7547a890166b7993658a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34e94070d7547a890166b7993658a9b">loadFromMemory</a> (const std::string &amp;vertexShader, const std::string &amp;fragmentShader)</td></tr>
<tr class="memdesc:ae34e94070d7547a890166b7993658a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from source codes in memory.  <br /></td></tr>
<tr class="separator:ae34e94070d7547a890166b7993658a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c8b715b02aba2cf7c0a0e0c0984250" id="r_ab8c8b715b02aba2cf7c0a0e0c0984250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8c8b715b02aba2cf7c0a0e0c0984250">loadFromMemory</a> (const std::string &amp;vertexShader, const std::string &amp;geometryShader, const std::string &amp;fragmentShader)</td></tr>
<tr class="memdesc:ab8c8b715b02aba2cf7c0a0e0c0984250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry and fragment shaders from source codes in memory.  <br /></td></tr>
<tr class="separator:ab8c8b715b02aba2cf7c0a0e0c0984250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1b130c0606e4f8bcdf65c1efc2a53" id="r_a2ee1b130c0606e4f8bcdf65c1efc2a53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53">loadFromStream</a> (<a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;stream, <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a> type)</td></tr>
<tr class="memdesc:a2ee1b130c0606e4f8bcdf65c1efc2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry or fragment shader from a custom stream.  <br /></td></tr>
<tr class="separator:a2ee1b130c0606e4f8bcdf65c1efc2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7958159ffb5596c4babc3052e35465" id="r_a3b7958159ffb5596c4babc3052e35465"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b7958159ffb5596c4babc3052e35465">loadFromStream</a> (<a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;vertexShaderStream, <a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;fragmentShaderStream)</td></tr>
<tr class="memdesc:a3b7958159ffb5596c4babc3052e35465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load both the vertex and fragment shaders from custom streams.  <br /></td></tr>
<tr class="separator:a3b7958159ffb5596c4babc3052e35465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08f1c091806205e6654db9d83197fcd" id="r_aa08f1c091806205e6654db9d83197fcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa08f1c091806205e6654db9d83197fcd">loadFromStream</a> (<a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;vertexShaderStream, <a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;geometryShaderStream, <a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;fragmentShaderStream)</td></tr>
<tr class="memdesc:aa08f1c091806205e6654db9d83197fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vertex, geometry and fragment shaders from custom streams.  <br /></td></tr>
<tr class="separator:aa08f1c091806205e6654db9d83197fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf78e3bea1e9b0bab850b6b0a0de29c7" id="r_abf78e3bea1e9b0bab850b6b0a0de29c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf78e3bea1e9b0bab850b6b0a0de29c7">setUniform</a> (const std::string &amp;name, float x)</td></tr>
<tr class="memdesc:abf78e3bea1e9b0bab850b6b0a0de29c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>float</code> uniform.  <br /></td></tr>
<tr class="separator:abf78e3bea1e9b0bab850b6b0a0de29c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2c673c41e37b17d67e4af1298b679f" id="r_a4a2c673c41e37b17d67e4af1298b679f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a2c673c41e37b17d67e4af1298b679f">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#adeed356d346d87634b4c197a530e4edf">Glsl::Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:a4a2c673c41e37b17d67e4af1298b679f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>vec2</code> uniform.  <br /></td></tr>
<tr class="separator:a4a2c673c41e37b17d67e4af1298b679f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad654ad8de6f0c56191fa7b8cea21db2" id="r_aad654ad8de6f0c56191fa7b8cea21db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad654ad8de6f0c56191fa7b8cea21db2">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a9bdd0463b7cb5316244a082007bd50f0">Glsl::Vec3</a> &amp;vector)</td></tr>
<tr class="memdesc:aad654ad8de6f0c56191fa7b8cea21db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>vec3</code> uniform.  <br /></td></tr>
<tr class="separator:aad654ad8de6f0c56191fa7b8cea21db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1aee8343800680fd62e1f3d43c24bf" id="r_abc1aee8343800680fd62e1f3d43c24bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1aee8343800680fd62e1f3d43c24bf">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">Glsl::Vec4</a> &amp;vector)</td></tr>
<tr class="memdesc:abc1aee8343800680fd62e1f3d43c24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>vec4</code> uniform.  <br /></td></tr>
<tr class="separator:abc1aee8343800680fd62e1f3d43c24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fc8b4c18e6b653952bce5c8c81e4a0" id="r_ae4fc8b4c18e6b653952bce5c8c81e4a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4fc8b4c18e6b653952bce5c8c81e4a0">setUniform</a> (const std::string &amp;name, int x)</td></tr>
<tr class="memdesc:ae4fc8b4c18e6b653952bce5c8c81e4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>int</code> uniform.  <br /></td></tr>
<tr class="separator:ae4fc8b4c18e6b653952bce5c8c81e4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb5bae59cedc7d6a9b533c97f7d1ed" id="r_a2ccb5bae59cedc7d6a9b533c97f7d1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccb5bae59cedc7d6a9b533c97f7d1ed">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#aab803ee70c4b7bfcd63ec09e10408fd3">Glsl::Ivec2</a> &amp;vector)</td></tr>
<tr class="memdesc:a2ccb5bae59cedc7d6a9b533c97f7d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>ivec2</code> uniform.  <br /></td></tr>
<tr class="separator:a2ccb5bae59cedc7d6a9b533c97f7d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e328e3e97cd753fdc7b842f4b0f202e" id="r_a9e328e3e97cd753fdc7b842f4b0f202e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e328e3e97cd753fdc7b842f4b0f202e">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a64f403dd0219e7f128ffddca641394df">Glsl::Ivec3</a> &amp;vector)</td></tr>
<tr class="memdesc:a9e328e3e97cd753fdc7b842f4b0f202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>ivec3</code> uniform.  <br /></td></tr>
<tr class="separator:a9e328e3e97cd753fdc7b842f4b0f202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380e7a5a2896162c5fd08966c4523790" id="r_a380e7a5a2896162c5fd08966c4523790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a380e7a5a2896162c5fd08966c4523790">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a778682c4f085d2daeb90c724791f3f68">Glsl::Ivec4</a> &amp;vector)</td></tr>
<tr class="memdesc:a380e7a5a2896162c5fd08966c4523790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>ivec4</code> uniform.  <br /></td></tr>
<tr class="separator:a380e7a5a2896162c5fd08966c4523790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af417027ac72c06e6cfbf30975cd678e9" id="r_af417027ac72c06e6cfbf30975cd678e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af417027ac72c06e6cfbf30975cd678e9">setUniform</a> (const std::string &amp;name, bool x)</td></tr>
<tr class="memdesc:af417027ac72c06e6cfbf30975cd678e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>bool</code> uniform.  <br /></td></tr>
<tr class="separator:af417027ac72c06e6cfbf30975cd678e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2518b8dd0762e682b452a5d5005f2bf" id="r_ab2518b8dd0762e682b452a5d5005f2bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2518b8dd0762e682b452a5d5005f2bf">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a59d8cf909c3d71ebf3db057480b464da">Glsl::Bvec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ab2518b8dd0762e682b452a5d5005f2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>bvec2</code> uniform.  <br /></td></tr>
<tr class="separator:ab2518b8dd0762e682b452a5d5005f2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06830875c82476fbb9c975cdeb78a11" id="r_ab06830875c82476fbb9c975cdeb78a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab06830875c82476fbb9c975cdeb78a11">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a4166ffc506619b4912d576e6eba2c957">Glsl::Bvec3</a> &amp;vector)</td></tr>
<tr class="memdesc:ab06830875c82476fbb9c975cdeb78a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>bvec3</code> uniform.  <br /></td></tr>
<tr class="separator:ab06830875c82476fbb9c975cdeb78a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db3e0adf1129abf24f0a51a7ec36f4" id="r_ac8db3e0adf1129abf24f0a51a7ec36f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8db3e0adf1129abf24f0a51a7ec36f4">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a8b1f0ac369666c48a9eafc9d3f5618e6">Glsl::Bvec4</a> &amp;vector)</td></tr>
<tr class="memdesc:ac8db3e0adf1129abf24f0a51a7ec36f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>bvec4</code> uniform.  <br /></td></tr>
<tr class="separator:ac8db3e0adf1129abf24f0a51a7ec36f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1198ae0152d439bc05781046883e281" id="r_ac1198ae0152d439bc05781046883e281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1198ae0152d439bc05781046883e281">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a9e984ebdc1cebc693a12f01a32b2d28d">Glsl::Mat3</a> &amp;matrix)</td></tr>
<tr class="memdesc:ac1198ae0152d439bc05781046883e281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>mat3</code> matrix.  <br /></td></tr>
<tr class="separator:ac1198ae0152d439bc05781046883e281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5c55c4a3b23d21e33dbdaab7990755" id="r_aca5c55c4a3b23d21e33dbdaab7990755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5c55c4a3b23d21e33dbdaab7990755">setUniform</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">Glsl::Mat4</a> &amp;matrix)</td></tr>
<tr class="memdesc:aca5c55c4a3b23d21e33dbdaab7990755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify value for <code>mat4</code> matrix.  <br /></td></tr>
<tr class="separator:aca5c55c4a3b23d21e33dbdaab7990755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7806a29ffbd0ee9251256a9e7265d479" id="r_a7806a29ffbd0ee9251256a9e7265d479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7806a29ffbd0ee9251256a9e7265d479">setUniform</a> (const std::string &amp;name, const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp;texture)</td></tr>
<tr class="memdesc:a7806a29ffbd0ee9251256a9e7265d479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a texture as <code>sampler2D</code> uniform.  <br /></td></tr>
<tr class="separator:a7806a29ffbd0ee9251256a9e7265d479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18f531e1f726b88fec1cf5a1e6af26d" id="r_ab18f531e1f726b88fec1cf5a1e6af26d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab18f531e1f726b88fec1cf5a1e6af26d">setUniform</a> (const std::string &amp;name, <a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a>)</td></tr>
<tr class="memdesc:ab18f531e1f726b88fec1cf5a1e6af26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify current texture as <code>sampler2D</code> uniform.  <br /></td></tr>
<tr class="separator:ab18f531e1f726b88fec1cf5a1e6af26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731d3b9953c50fe7d3fb03340b97deff" id="r_a731d3b9953c50fe7d3fb03340b97deff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a731d3b9953c50fe7d3fb03340b97deff">setUniformArray</a> (const std::string &amp;name, const float *scalarArray, std::size_t length)</td></tr>
<tr class="memdesc:a731d3b9953c50fe7d3fb03340b97deff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>float</code>[] array uniform.  <br /></td></tr>
<tr class="separator:a731d3b9953c50fe7d3fb03340b97deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e2eab45d9a091f3720c0879a5bb026" id="r_ab2e2eab45d9a091f3720c0879a5bb026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2e2eab45d9a091f3720c0879a5bb026">setUniformArray</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#adeed356d346d87634b4c197a530e4edf">Glsl::Vec2</a> *vectorArray, std::size_t length)</td></tr>
<tr class="memdesc:ab2e2eab45d9a091f3720c0879a5bb026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>vec2</code>[] array uniform.  <br /></td></tr>
<tr class="separator:ab2e2eab45d9a091f3720c0879a5bb026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae884292fed977bbea5039818f208e7" id="r_aeae884292fed977bbea5039818f208e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae884292fed977bbea5039818f208e7">setUniformArray</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a9bdd0463b7cb5316244a082007bd50f0">Glsl::Vec3</a> *vectorArray, std::size_t length)</td></tr>
<tr class="memdesc:aeae884292fed977bbea5039818f208e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>vec3</code>[] array uniform.  <br /></td></tr>
<tr class="separator:aeae884292fed977bbea5039818f208e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ac1ea7918c9b1c2232df59affb7fa" id="r_aa89ac1ea7918c9b1c2232df59affb7fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa89ac1ea7918c9b1c2232df59affb7fa">setUniformArray</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">Glsl::Vec4</a> *vectorArray, std::size_t length)</td></tr>
<tr class="memdesc:aa89ac1ea7918c9b1c2232df59affb7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>vec4</code>[] array uniform.  <br /></td></tr>
<tr class="separator:aa89ac1ea7918c9b1c2232df59affb7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69587701d347ba21d506197d0fb9f842" id="r_a69587701d347ba21d506197d0fb9f842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69587701d347ba21d506197d0fb9f842">setUniformArray</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a9e984ebdc1cebc693a12f01a32b2d28d">Glsl::Mat3</a> *matrixArray, std::size_t length)</td></tr>
<tr class="memdesc:a69587701d347ba21d506197d0fb9f842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>mat3</code>[] array uniform.  <br /></td></tr>
<tr class="separator:a69587701d347ba21d506197d0fb9f842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066b0ba02e1c1bddc9e2571eca1156ab" id="r_a066b0ba02e1c1bddc9e2571eca1156ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a066b0ba02e1c1bddc9e2571eca1156ab">setUniformArray</a> (const std::string &amp;name, const <a class="el" href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">Glsl::Mat4</a> *matrixArray, std::size_t length)</td></tr>
<tr class="memdesc:a066b0ba02e1c1bddc9e2571eca1156ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify values for <code>mat4</code>[] array uniform.  <br /></td></tr>
<tr class="separator:a066b0ba02e1c1bddc9e2571eca1156ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4dd78f0752ae08664b4ee616db1cf" id="r_a47e4dd78f0752ae08664b4ee616db1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e4dd78f0752ae08664b4ee616db1cf">setParameter</a> (const std::string &amp;name, float x)</td></tr>
<tr class="memdesc:a47e4dd78f0752ae08664b4ee616db1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a float parameter of the shader.  <br /></td></tr>
<tr class="separator:a47e4dd78f0752ae08664b4ee616db1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d379f40810b8e3eadebee81aedd231" id="r_ab8d379f40810b8e3eadebee81aedd231"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8d379f40810b8e3eadebee81aedd231">setParameter</a> (const std::string &amp;name, float x, float y)</td></tr>
<tr class="memdesc:ab8d379f40810b8e3eadebee81aedd231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 2-components vector parameter of the shader.  <br /></td></tr>
<tr class="separator:ab8d379f40810b8e3eadebee81aedd231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e36e044d6b8adca8339f40c5a4b1801" id="r_a7e36e044d6b8adca8339f40c5a4b1801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e36e044d6b8adca8339f40c5a4b1801">setParameter</a> (const std::string &amp;name, float x, float y, float z)</td></tr>
<tr class="memdesc:a7e36e044d6b8adca8339f40c5a4b1801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 3-components vector parameter of the shader.  <br /></td></tr>
<tr class="separator:a7e36e044d6b8adca8339f40c5a4b1801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb468f1bc2d26750b96b74f1e19027fb" id="r_aeb468f1bc2d26750b96b74f1e19027fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb468f1bc2d26750b96b74f1e19027fb">setParameter</a> (const std::string &amp;name, float x, float y, float z, float w)</td></tr>
<tr class="memdesc:aeb468f1bc2d26750b96b74f1e19027fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 4-components vector parameter of the shader.  <br /></td></tr>
<tr class="separator:aeb468f1bc2d26750b96b74f1e19027fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac473ece2c6fa26dc5032c07fd7288e" id="r_a3ac473ece2c6fa26dc5032c07fd7288e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ac473ece2c6fa26dc5032c07fd7288e">setParameter</a> (const std::string &amp;name, const <a class="el" href="namespacesf.html#acf03098c2577b869e2fa6836cc48f1a0">Vector2f</a> &amp;vector)</td></tr>
<tr class="memdesc:a3ac473ece2c6fa26dc5032c07fd7288e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 2-components vector parameter of the shader.  <br /></td></tr>
<tr class="separator:a3ac473ece2c6fa26dc5032c07fd7288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4a0c6dc70ae68aecc0dda3f343c07" id="r_a87d4a0c6dc70ae68aecc0dda3f343c07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87d4a0c6dc70ae68aecc0dda3f343c07">setParameter</a> (const std::string &amp;name, const <a class="el" href="namespacesf.html#af97357d7d32e7d6a700d03be2f3b4811">Vector3f</a> &amp;vector)</td></tr>
<tr class="memdesc:a87d4a0c6dc70ae68aecc0dda3f343c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a 3-components vector parameter of the shader.  <br /></td></tr>
<tr class="separator:a87d4a0c6dc70ae68aecc0dda3f343c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8618119ed4399df3fd33e78ee96b4fc" id="r_aa8618119ed4399df3fd33e78ee96b4fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8618119ed4399df3fd33e78ee96b4fc">setParameter</a> (const std::string &amp;name, const <a class="el" href="classsf_1_1Color.html">Color</a> &amp;color)</td></tr>
<tr class="memdesc:aa8618119ed4399df3fd33e78ee96b4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a color parameter of the shader.  <br /></td></tr>
<tr class="separator:aa8618119ed4399df3fd33e78ee96b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8599ee1348407025039b89ddf3f7cb62" id="r_a8599ee1348407025039b89ddf3f7cb62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8599ee1348407025039b89ddf3f7cb62">setParameter</a> (const std::string &amp;name, const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;transform)</td></tr>
<tr class="memdesc:a8599ee1348407025039b89ddf3f7cb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a matrix parameter of the shader.  <br /></td></tr>
<tr class="separator:a8599ee1348407025039b89ddf3f7cb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58ab5c0a1084f238dfcec86602daa1" id="r_a7f58ab5c0a1084f238dfcec86602daa1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f58ab5c0a1084f238dfcec86602daa1">setParameter</a> (const std::string &amp;name, const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp;texture)</td></tr>
<tr class="memdesc:a7f58ab5c0a1084f238dfcec86602daa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a texture parameter of the shader.  <br /></td></tr>
<tr class="separator:a7f58ab5c0a1084f238dfcec86602daa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b4cba0bab915fa01032b063909044" id="r_af06b4cba0bab915fa01032b063909044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af06b4cba0bab915fa01032b063909044">setParameter</a> (const std::string &amp;name, <a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a>)</td></tr>
<tr class="memdesc:af06b4cba0bab915fa01032b063909044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a texture parameter of the shader.  <br /></td></tr>
<tr class="separator:af06b4cba0bab915fa01032b063909044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14d0bf7afe7b6bb415d309f9c707188" id="r_ac14d0bf7afe7b6bb415d309f9c707188"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac14d0bf7afe7b6bb415d309f9c707188">getNativeHandle</a> () const</td></tr>
<tr class="memdesc:ac14d0bf7afe7b6bb415d309f9c707188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying OpenGL handle of the shader.  <br /></td></tr>
<tr class="separator:ac14d0bf7afe7b6bb415d309f9c707188"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09778f78afcbeb854d608c8dacd8ea30" id="r_a09778f78afcbeb854d608c8dacd8ea30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09778f78afcbeb854d608c8dacd8ea30">bind</a> (const <a class="el" href="classsf_1_1Shader.html">Shader</a> *shader)</td></tr>
<tr class="memdesc:a09778f78afcbeb854d608c8dacd8ea30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a shader for rendering.  <br /></td></tr>
<tr class="separator:a09778f78afcbeb854d608c8dacd8ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22474690bafe4a305c1b9826b1bd86a" id="r_ad22474690bafe4a305c1b9826b1bd86a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad22474690bafe4a305c1b9826b1bd86a">isAvailable</a> ()</td></tr>
<tr class="memdesc:ad22474690bafe4a305c1b9826b1bd86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the system supports shaders.  <br /></td></tr>
<tr class="separator:ad22474690bafe4a305c1b9826b1bd86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db14baf1bbc688577f81813b1fce96" id="r_a45db14baf1bbc688577f81813b1fce96"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45db14baf1bbc688577f81813b1fce96">isGeometryAvailable</a> ()</td></tr>
<tr class="memdesc:a45db14baf1bbc688577f81813b1fce96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether or not the system supports geometry shaders.  <br /></td></tr>
<tr class="separator:a45db14baf1bbc688577f81813b1fce96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac84c7953eec2e19358ea6e2cc5385b8d" id="r_ac84c7953eec2e19358ea6e2cc5385b8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84c7953eec2e19358ea6e2cc5385b8d">CurrentTexture</a></td></tr>
<tr class="memdesc:ac84c7953eec2e19358ea6e2cc5385b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the texture of the object being drawn.  <br /></td></tr>
<tr class="separator:ac84c7953eec2e19358ea6e2cc5385b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">Shader</a> class (vertex, geometry and fragment) </p>
<p>Shaders are programs written using a specific language, executed directly by the graphics card and allowing to apply real-time operations to the rendered entities.</p>
<p>There are three kinds of shaders: </p><ul>
<li>Vertex shaders, that process vertices </li>
<li>Geometry shaders, that process primitives </li>
<li>Fragment (pixel) shaders, that process pixels</li>
</ul>
<p>A <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> can be composed of either a vertex shader alone, a geometry shader alone, a fragment shader alone, or any combination of them. (see the variants of the load functions).</p>
<p>Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for SFML.</p>
<p>Like any C/C++ program, a GLSL shader has its own variables called <em>uniforms</em> that you can set from your C++ application. <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> handles different types of uniforms: </p><ul>
<li>scalars: <code>float</code>, <code>int</code>, <code>bool</code> </li>
<li>vectors (2, 3 or 4 components) </li>
<li>matrices (3x3 or 4x4) </li>
<li>samplers (textures)</li>
</ul>
<p>Some SFML-specific types can be converted: </p><ul>
<li><a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color</a> as a 4D vector (<code>vec4</code>) </li>
<li><a class="el" href="classsf_1_1Transform.html" title="Define a 3x3 transform matrix.">sf::Transform</a> as matrices (<code>mat3</code> or <code>mat4</code>)</li>
</ul>
<p>Every uniform variable in a shader can be set through one of the <a class="el" href="#abf78e3bea1e9b0bab850b6b0a0de29c7" title="Specify value for float uniform.">setUniform()</a> or <a class="el" href="#a731d3b9953c50fe7d3fb03340b97deff" title="Specify values for float[] array uniform.">setUniformArray()</a> overloads. For example, if you have a shader with the following uniforms: </p><div class="fragment"><div class="line">uniform <span class="keywordtype">float</span> offset;</div>
<div class="line">uniform vec3 point;</div>
<div class="line">uniform vec4 color;</div>
<div class="line">uniform mat4 matrix;</div>
<div class="line">uniform sampler2D overlay;</div>
<div class="line">uniform sampler2D current;</div>
</div><!-- fragment --><p> You can set their values from C++ code as follows, using the types defined in the <a class="el" href="namespacesf_1_1Glsl.html" title="Namespace with GLSL types.">sf::Glsl</a> namespace: </p><div class="fragment"><div class="line">shader.setUniform(<span class="stringliteral">&quot;offset&quot;</span>, 2.f);</div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;point&quot;</span>, <a class="code hl_class" href="classsf_1_1Vector3.html">sf::Vector3f</a>(0.5f, 0.8f, 0.3f));</div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;color&quot;</span>, <a class="code hl_typedef" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">sf::Glsl::Vec4</a>(color));          <span class="comment">// color is a sf::Color</span></div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;matrix&quot;</span>, <a class="code hl_typedef" href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">sf::Glsl::Mat4</a>(transform));     <span class="comment">// transform is a sf::Transform</span></div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;overlay&quot;</span>, texture);                      <span class="comment">// texture is a sf::Texture</span></div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;current&quot;</span>, <a class="code hl_variable" href="#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>);</div>
<div class="ttc" id="aclasssf_1_1Shader_html_ac84c7953eec2e19358ea6e2cc5385b8d"><div class="ttname"><a href="#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a></div><div class="ttdeci">static CurrentTextureType CurrentTexture</div><div class="ttdoc">Represents the texture of the object being drawn.</div><div class="ttdef"><b>Definition</b> <a href="Shader_8hpp_source.html#l00082">Shader.hpp:82</a></div></div>
<div class="ttc" id="aclasssf_1_1Vector3_html"><div class="ttname"><a href="classsf_1_1Vector3.html">sf::Vector3</a></div><div class="ttdoc">Utility template class for manipulating 3-dimensional vectors.</div><div class="ttdef"><b>Definition</b> <a href="Vector3_8hpp_source.html#l00037">Vector3.hpp:38</a></div></div>
<div class="ttc" id="anamespacesf_1_1Glsl_html_a769de806596348a8e56ed6506c688271"><div class="ttname"><a href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">sf::Glsl::Mat4</a></div><div class="ttdeci">implementation defined Mat4</div><div class="ttdoc">4x4 float matrix (mat4 in GLSL)</div><div class="ttdef"><b>Definition</b> <a href="Glsl_8hpp_source.html#l00181">Glsl.hpp:181</a></div></div>
<div class="ttc" id="anamespacesf_1_1Glsl_html_a7c67253548c58adb77cb14f847f18f83"><div class="ttname"><a href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">sf::Glsl::Vec4</a></div><div class="ttdeci">implementation defined Vec4</div><div class="ttdoc">4D float vector (vec4 in GLSL)</div><div class="ttdef"><b>Definition</b> <a href="Glsl_8hpp_source.html#l00110">Glsl.hpp:110</a></div></div>
</div><!-- fragment --><p>The old <a class="el" href="#a47e4dd78f0752ae08664b4ee616db1cf" title="Change a float parameter of the shader.">setParameter()</a> overloads are deprecated and will be removed in a future version. You should use their <a class="el" href="#abf78e3bea1e9b0bab850b6b0a0de29c7" title="Specify value for float uniform.">setUniform()</a> equivalents instead.</p>
<p>The special <a class="el" href="#ac84c7953eec2e19358ea6e2cc5385b8d" title="Represents the texture of the object being drawn.">Shader::CurrentTexture</a> argument maps the given <code>sampler2D</code> uniform to the current texture of the object being drawn (which cannot be known in advance).</p>
<p>To apply a shader to a drawable, you must pass it as an additional parameter to the <a class="el" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">RenderWindow::draw</a> function: </p><div class="fragment"><div class="line">window.draw(sprite, &amp;shader);</div>
</div><!-- fragment --><p>... which is in fact just a shortcut for this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1RenderStates.html">sf::RenderStates</a> states;</div>
<div class="line">states.<a class="code hl_variable" href="classsf_1_1RenderStates.html#ad4f79ecdd0c60ed0d24fbe555b221bd8">shader</a> = &amp;shader;</div>
<div class="line">window.draw(sprite, states);</div>
<div class="ttc" id="aclasssf_1_1RenderStates_html"><div class="ttname"><a href="classsf_1_1RenderStates.html">sf::RenderStates</a></div><div class="ttdoc">Define the states used for drawing to a RenderTarget.</div><div class="ttdef"><b>Definition</b> <a href="RenderStates_8hpp_source.html#l00045">RenderStates.hpp:46</a></div></div>
<div class="ttc" id="aclasssf_1_1RenderStates_html_ad4f79ecdd0c60ed0d24fbe555b221bd8"><div class="ttname"><a href="classsf_1_1RenderStates.html#ad4f79ecdd0c60ed0d24fbe555b221bd8">sf::RenderStates::shader</a></div><div class="ttdeci">const Shader * shader</div><div class="ttdoc">Shader.</div><div class="ttdef"><b>Definition</b> <a href="RenderStates_8hpp_source.html#l00118">RenderStates.hpp:118</a></div></div>
</div><!-- fragment --><p>In the code above we pass a pointer to the shader, because it may be null (which means "no shader").</p>
<p>Shaders can be used on any drawable, but some combinations are not interesting. For example, using a vertex shader on a <a class="el" href="classsf_1_1Sprite.html" title="Drawable representation of a texture, with its own transformations, color, etc.">sf::Sprite</a> is limited because there are only 4 vertices, the sprite would have to be subdivided in order to apply wave effects. Another bad example is a fragment shader with <a class="el" href="classsf_1_1Text.html" title="Graphical text that can be drawn to a render target.">sf::Text</a>: the texture of the text is not the actual text that you see on screen, it is a big texture containing all the characters of the font in an arbitrary order; thus, texture lookups on pixels other than the current one may not give you the expected result.</p>
<p>Shaders can also be used to apply global post-effects to the current contents of the target (like the old sf::PostFx class in SFML 1). This can be done in two different ways: </p><ul>
<li>draw everything to a <a class="el" href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a>, then draw it to the main target using the shader </li>
<li>draw everything directly to the main target, then use sf::Texture::update(Window&amp;) to copy its contents to a texture and draw it to the main target using the shader</li>
</ul>
<p>The first technique is more optimized because it doesn't involve retrieving the target's pixels to system memory, but the second one doesn't impact the rendering process and can be easily inserted anywhere without impacting all the code.</p>
<p>Like <a class="el" href="classsf_1_1Texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> that can be used as a raw OpenGL texture, <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> can also be used directly as a raw shader for custom OpenGL geometry. </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a09778f78afcbeb854d608c8dacd8ea30">sf::Shader::bind</a>(&amp;shader);</div>
<div class="line">... render OpenGL geometry ...</div>
<div class="line">sf::Shader::bind(NULL);</div>
<div class="ttc" id="aclasssf_1_1Shader_html_a09778f78afcbeb854d608c8dacd8ea30"><div class="ttname"><a href="#a09778f78afcbeb854d608c8dacd8ea30">sf::Shader::bind</a></div><div class="ttdeci">static void bind(const Shader *shader)</div><div class="ttdoc">Bind a shader for rendering.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesf_1_1Glsl.html" title="Namespace with GLSL types.">sf::Glsl</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Shader_8hpp_source.html#l00052">52</a> of file <a class="el" href="Shader_8hpp_source.html">Shader.hpp</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afaa1aa65e5de37b74d047da9def9f9b3" name="afaa1aa65e5de37b74d047da9def9f9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa1aa65e5de37b74d047da9def9f9b3">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">sf::Shader::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of shaders. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce" name="afaa1aa65e5de37b74d047da9def9f9b3a8718008f827eb32e29bbdd1791c62dce"></a>Vertex&#160;</td><td class="fielddoc"><p>Vertex shader </p>
</td></tr>
<tr><td class="fieldname"><a id="afaa1aa65e5de37b74d047da9def9f9b3a812421100fd57456727375938fb62788" name="afaa1aa65e5de37b74d047da9def9f9b3a812421100fd57456727375938fb62788"></a>Geometry&#160;</td><td class="fielddoc"><p>Geometry shader. </p>
</td></tr>
<tr><td class="fieldname"><a id="afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a" name="afaa1aa65e5de37b74d047da9def9f9b3ace6e88eec3a56b2e55ee3c8e64e9b89a"></a>Fragment&#160;</td><td class="fielddoc"><p>Fragment (pixel) shader. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Shader_8hpp_source.html#l00060">60</a> of file <a class="el" href="Shader_8hpp_source.html">Shader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d7f28f26b4122959fcafec871c2c3c5" name="a1d7f28f26b4122959fcafec871c2c3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7f28f26b4122959fcafec871c2c3c5">&#9670;&#160;</a></span>Shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::Shader::Shader </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This constructor creates an invalid shader. </p>

</div>
</div>
<a id="a4bac6cc8b046ecd8fb967c145a2380e6" name="a4bac6cc8b046ecd8fb967c145a2380e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bac6cc8b046ecd8fb967c145a2380e6">&#9670;&#160;</a></span>~Shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::Shader::~Shader </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09778f78afcbeb854d608c8dacd8ea30" name="a09778f78afcbeb854d608c8dacd8ea30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09778f78afcbeb854d608c8dacd8ea30">&#9670;&#160;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sf::Shader::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Shader.html">Shader</a> *</td>          <td class="paramname"><span class="paramname"><em>shader</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a shader for rendering. </p>
<p>This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> with OpenGL code.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Shader.html">sf::Shader</a> s1, s2;</div>
<div class="line">...</div>
<div class="line">sf::Shader::bind(&amp;s1);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use s1...</span></div>
<div class="line"><a class="code hl_function" href="#a09778f78afcbeb854d608c8dacd8ea30">sf::Shader::bind</a>(&amp;s2);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use s2...</span></div>
<div class="line"><a class="code hl_function" href="#a09778f78afcbeb854d608c8dacd8ea30">sf::Shader::bind</a>(NULL);</div>
<div class="line"><span class="comment">// draw OpenGL stuff that use no shader...</span></div>
<div class="ttc" id="aclasssf_1_1Shader_html"><div class="ttname"><a href="classsf_1_1Shader.html">sf::Shader</a></div><div class="ttdoc">Shader class (vertex, geometry and fragment)</div><div class="ttdef"><b>Definition</b> <a href="Shader_8hpp_source.html#l00052">Shader.hpp:53</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">Shader</a> to bind, can be null to use no shader </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac14d0bf7afe7b6bb415d309f9c707188" name="ac14d0bf7afe7b6bb415d309f9c707188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14d0bf7afe7b6bb415d309f9c707188">&#9670;&#160;</a></span>getNativeHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sf::Shader::getNativeHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the underlying OpenGL handle of the shader. </p>
<p>You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed.</p>
<dl class="section return"><dt>Returns</dt><dd>OpenGL handle of the shader or 0 if not yet loaded </dd></dl>

</div>
</div>
<a id="ad22474690bafe4a305c1b9826b1bd86a" name="ad22474690bafe4a305c1b9826b1bd86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22474690bafe4a305c1b9826b1bd86a">&#9670;&#160;</a></span>isAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sf::Shader::isAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether or not the system supports shaders. </p>
<p>This function should always be called before using the shader features. If it returns false, then any attempt to use <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> will fail.</p>
<dl class="section return"><dt>Returns</dt><dd>True if shaders are supported, false otherwise </dd></dl>

</div>
</div>
<a id="a45db14baf1bbc688577f81813b1fce96" name="a45db14baf1bbc688577f81813b1fce96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db14baf1bbc688577f81813b1fce96">&#9670;&#160;</a></span>isGeometryAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool sf::Shader::isGeometryAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether or not the system supports geometry shaders. </p>
<p>This function should always be called before using the geometry shader features. If it returns false, then any attempt to use <a class="el" href="classsf_1_1Shader.html" title="Shader class (vertex, geometry and fragment)">sf::Shader</a> geometry shader features will fail.</p>
<p>This function can only return true if <a class="el" href="#ad22474690bafe4a305c1b9826b1bd86a" title="Tell whether or not the system supports shaders.">isAvailable()</a> would also return true, since shaders in general have to be supported in order for geometry shaders to be supported as well.</p>
<p>Note: The first call to this function, whether by your code or SFML will result in a context switch.</p>
<dl class="section return"><dt>Returns</dt><dd>True if geometry shaders are supported, false otherwise </dd></dl>

</div>
</div>
<a id="a053a5632848ebaca2fcd8ba29abe9e6e" name="a053a5632848ebaca2fcd8ba29abe9e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053a5632848ebaca2fcd8ba29abe9e6e">&#9670;&#160;</a></span>loadFromFile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry or fragment shader from a file. </p>
<p>This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source must be a text file containing a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Path of the vertex, geometry or fragment shader file to load </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex, geometry or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="ac9d7289966fcef562eeb92271c03e3dc" name="ac9d7289966fcef562eeb92271c03e3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d7289966fcef562eeb92271c03e3dc">&#9670;&#160;</a></span>loadFromFile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShaderFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShaderFilename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load both the vertex and fragment shaders from files. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderFilename</td><td>Path of the vertex shader file to load </td></tr>
    <tr><td class="paramname">fragmentShaderFilename</td><td>Path of the fragment shader file to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="a295d8468811ca15bf9c5401a7a7d4f54" name="a295d8468811ca15bf9c5401a7a7d4f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295d8468811ca15bf9c5401a7a7d4f54">&#9670;&#160;</a></span>loadFromFile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShaderFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>geometryShaderFilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShaderFilename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry and fragment shaders from files. </p>
<p>This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderFilename</td><td>Path of the vertex shader file to load </td></tr>
    <tr><td class="paramname">geometryShaderFilename</td><td>Path of the geometry shader file to load </td></tr>
    <tr><td class="paramname">fragmentShaderFilename</td><td>Path of the fragment shader file to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="ac92d46bf71dff2d791117e4e472148aa" name="ac92d46bf71dff2d791117e4e472148aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92d46bf71dff2d791117e4e472148aa">&#9670;&#160;</a></span>loadFromMemory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry or fragment shader from a source code in memory. </p>
<p>This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the shader </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex, geometry or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="ae34e94070d7547a890166b7993658a9b" name="ae34e94070d7547a890166b7993658a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34e94070d7547a890166b7993658a9b">&#9670;&#160;</a></span>loadFromMemory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShader</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load both the vertex and fragment shaders from source codes in memory. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the vertex shader </td></tr>
    <tr><td class="paramname">fragmentShader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the fragment shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="ab8c8b715b02aba2cf7c0a0e0c0984250" name="ab8c8b715b02aba2cf7c0a0e0c0984250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c8b715b02aba2cf7c0a0e0c0984250">&#9670;&#160;</a></span>loadFromMemory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>geometryShader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShader</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry and fragment shaders from source codes in memory. </p>
<p>This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the vertex shader </td></tr>
    <tr><td class="paramname">geometryShader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the geometry shader </td></tr>
    <tr><td class="paramname">fragmentShader</td><td><a class="el" href="classsf_1_1String.html" title="Utility string class that automatically handles conversions between types and encodings.">String</a> containing the source code of the fragment shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#a2ee1b130c0606e4f8bcdf65c1efc2a53" title="Load the vertex, geometry or fragment shader from a custom stream.">loadFromStream</a> </dd></dl>

</div>
</div>
<a id="a2ee1b130c0606e4f8bcdf65c1efc2a53" name="a2ee1b130c0606e4f8bcdf65c1efc2a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee1b130c0606e4f8bcdf65c1efc2a53">&#9670;&#160;</a></span>loadFromStream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afaa1aa65e5de37b74d047da9def9f9b3">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry or fragment shader from a custom stream. </p>
<p>This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Source stream to read from </td></tr>
    <tr><td class="paramname">type</td><td>Type of shader (vertex, geometry or fragment)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a id="a3b7958159ffb5596c4babc3052e35465" name="a3b7958159ffb5596c4babc3052e35465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7958159ffb5596c4babc3052e35465">&#9670;&#160;</a></span>loadFromStream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShaderStream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShaderStream</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load both the vertex and fragment shaders from custom streams. </p>
<p>This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderStream</td><td>Source stream to read the vertex shader from </td></tr>
    <tr><td class="paramname">fragmentShaderStream</td><td>Source stream to read the fragment shader from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a id="aa08f1c091806205e6654db9d83197fcd" name="aa08f1c091806205e6654db9d83197fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f1c091806205e6654db9d83197fcd">&#9670;&#160;</a></span>loadFromStream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::Shader::loadFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vertexShaderStream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geometryShaderStream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsf_1_1InputStream.html">InputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fragmentShaderStream</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the vertex, geometry and fragment shaders from custom streams. </p>
<p>This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexShaderStream</td><td>Source stream to read the vertex shader from </td></tr>
    <tr><td class="paramname">geometryShaderStream</td><td>Source stream to read the geometry shader from </td></tr>
    <tr><td class="paramname">fragmentShaderStream</td><td>Source stream to read the fragment shader from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if loading succeeded, false if it failed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a053a5632848ebaca2fcd8ba29abe9e6e" title="Load the vertex, geometry or fragment shader from a file.">loadFromFile</a>, <a class="el" href="#ac92d46bf71dff2d791117e4e472148aa" title="Load the vertex, geometry or fragment shader from a source code in memory.">loadFromMemory</a> </dd></dl>

</div>
</div>
<a id="aa8618119ed4399df3fd33e78ee96b4fc" name="aa8618119ed4399df3fd33e78ee96b4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8618119ed4399df3fd33e78ee96b4fc">&#9670;&#160;</a></span>setParameter() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Color.html">Color</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a color parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd>Use <a class="el" href="#abc1aee8343800680fd62e1f3d43c24bf" title="Specify value for vec4 uniform.">setUniform(const std::string&amp;, const Glsl::Vec4&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a7f58ab5c0a1084f238dfcec86602daa1" name="a7f58ab5c0a1084f238dfcec86602daa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58ab5c0a1084f238dfcec86602daa1">&#9670;&#160;</a></span>setParameter() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>texture</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a texture parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated</a></b></dt><dd>Use <a class="el" href="#a7806a29ffbd0ee9251256a9e7265d479" title="Specify a texture as sampler2D uniform.">setUniform(const std::string&amp;, const Texture&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a8599ee1348407025039b89ddf3f7cb62" name="a8599ee1348407025039b89ddf3f7cb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8599ee1348407025039b89ddf3f7cb62">&#9670;&#160;</a></span>setParameter() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Transform.html">Transform</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a matrix parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated</a></b></dt><dd>Use <a class="el" href="#abc1aee8343800680fd62e1f3d43c24bf" title="Specify value for vec4 uniform.">setUniform(const std::string&amp;, const Glsl::Mat4&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a3ac473ece2c6fa26dc5032c07fd7288e" name="a3ac473ece2c6fa26dc5032c07fd7288e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac473ece2c6fa26dc5032c07fd7288e">&#9670;&#160;</a></span>setParameter() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf.html#acf03098c2577b869e2fa6836cc48f1a0">Vector2f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a 2-components vector parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated</a></b></dt><dd>Use <a class="el" href="#a4a2c673c41e37b17d67e4af1298b679f" title="Specify value for vec2 uniform.">setUniform(const std::string&amp;, const Glsl::Vec2&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a87d4a0c6dc70ae68aecc0dda3f343c07" name="a87d4a0c6dc70ae68aecc0dda3f343c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d4a0c6dc70ae68aecc0dda3f343c07">&#9670;&#160;</a></span>setParameter() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf.html#af97357d7d32e7d6a700d03be2f3b4811">Vector3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a 3-components vector parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd>Use <a class="el" href="#aad654ad8de6f0c56191fa7b8cea21db2" title="Specify value for vec3 uniform.">setUniform(const std::string&amp;, const Glsl::Vec3&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="af06b4cba0bab915fa01032b063909044" name="af06b4cba0bab915fa01032b063909044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b4cba0bab915fa01032b063909044">&#9670;&#160;</a></span>setParameter() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a texture parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated</a></b></dt><dd>Use <a class="el" href="#ab18f531e1f726b88fec1cf5a1e6af26d" title="Specify current texture as sampler2D uniform.">setUniform(const std::string&amp;, CurrentTextureType)</a> instead.</dd></dl>

</div>
</div>
<a id="a47e4dd78f0752ae08664b4ee616db1cf" name="a47e4dd78f0752ae08664b4ee616db1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e4dd78f0752ae08664b4ee616db1cf">&#9670;&#160;</a></span>setParameter() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a float parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated</a></b></dt><dd>Use <a class="el" href="#abf78e3bea1e9b0bab850b6b0a0de29c7" title="Specify value for float uniform.">setUniform(const std::string&amp;, float)</a> instead.</dd></dl>

</div>
</div>
<a id="ab8d379f40810b8e3eadebee81aedd231" name="ab8d379f40810b8e3eadebee81aedd231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d379f40810b8e3eadebee81aedd231">&#9670;&#160;</a></span>setParameter() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a 2-components vector parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated</a></b></dt><dd>Use <a class="el" href="#a4a2c673c41e37b17d67e4af1298b679f" title="Specify value for vec2 uniform.">setUniform(const std::string&amp;, const Glsl::Vec2&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a7e36e044d6b8adca8339f40c5a4b1801" name="a7e36e044d6b8adca8339f40c5a4b1801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e36e044d6b8adca8339f40c5a4b1801">&#9670;&#160;</a></span>setParameter() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a 3-components vector parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated</a></b></dt><dd>Use <a class="el" href="#aad654ad8de6f0c56191fa7b8cea21db2" title="Specify value for vec3 uniform.">setUniform(const std::string&amp;, const Glsl::Vec3&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="aeb468f1bc2d26750b96b74f1e19027fb" name="aeb468f1bc2d26750b96b74f1e19027fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb468f1bc2d26750b96b74f1e19027fb">&#9670;&#160;</a></span>setParameter() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setParameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a 4-components vector parameter of the shader. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated</a></b></dt><dd>Use <a class="el" href="#abc1aee8343800680fd62e1f3d43c24bf" title="Specify value for vec4 uniform.">setUniform(const std::string&amp;, const Glsl::Vec4&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="af417027ac72c06e6cfbf30975cd678e9" name="af417027ac72c06e6cfbf30975cd678e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af417027ac72c06e6cfbf30975cd678e9">&#9670;&#160;</a></span>setUniform() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>bool</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">x</td><td>Value of the bool scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2518b8dd0762e682b452a5d5005f2bf" name="ab2518b8dd0762e682b452a5d5005f2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2518b8dd0762e682b452a5d5005f2bf">&#9670;&#160;</a></span>setUniform() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a59d8cf909c3d71ebf3db057480b464da">Glsl::Bvec2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>bvec2</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the bvec2 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06830875c82476fbb9c975cdeb78a11" name="ab06830875c82476fbb9c975cdeb78a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06830875c82476fbb9c975cdeb78a11">&#9670;&#160;</a></span>setUniform() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a4166ffc506619b4912d576e6eba2c957">Glsl::Bvec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>bvec3</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the bvec3 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8db3e0adf1129abf24f0a51a7ec36f4" name="ac8db3e0adf1129abf24f0a51a7ec36f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8db3e0adf1129abf24f0a51a7ec36f4">&#9670;&#160;</a></span>setUniform() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a8b1f0ac369666c48a9eafc9d3f5618e6">Glsl::Bvec4</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>bvec4</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the bvec4 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ccb5bae59cedc7d6a9b533c97f7d1ed" name="a2ccb5bae59cedc7d6a9b533c97f7d1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb5bae59cedc7d6a9b533c97f7d1ed">&#9670;&#160;</a></span>setUniform() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#aab803ee70c4b7bfcd63ec09e10408fd3">Glsl::Ivec2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>ivec2</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the ivec2 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e328e3e97cd753fdc7b842f4b0f202e" name="a9e328e3e97cd753fdc7b842f4b0f202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e328e3e97cd753fdc7b842f4b0f202e">&#9670;&#160;</a></span>setUniform() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a64f403dd0219e7f128ffddca641394df">Glsl::Ivec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>ivec3</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the ivec3 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a380e7a5a2896162c5fd08966c4523790" name="a380e7a5a2896162c5fd08966c4523790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380e7a5a2896162c5fd08966c4523790">&#9670;&#160;</a></span>setUniform() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a778682c4f085d2daeb90c724791f3f68">Glsl::Ivec4</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>ivec4</code> uniform. </p>
<p>This overload can also be called with <a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color</a> objects that are converted to <a class="el" href="namespacesf_1_1Glsl.html#a778682c4f085d2daeb90c724791f3f68" title="4D int vector (ivec4 in GLSL)">sf::Glsl::Ivec4</a>.</p>
<p>If color conversions are used, the ivec4 uniform in GLSL will hold the same values as the original <a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color</a> instance. For example, <a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color(255, 127, 0, 255)</a> is mapped to ivec4(255, 127, 0, 255).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the ivec4 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1198ae0152d439bc05781046883e281" name="ac1198ae0152d439bc05781046883e281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1198ae0152d439bc05781046883e281">&#9670;&#160;</a></span>setUniform() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a9e984ebdc1cebc693a12f01a32b2d28d">Glsl::Mat3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>mat3</code> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">matrix</td><td>Value of the mat3 matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca5c55c4a3b23d21e33dbdaab7990755" name="aca5c55c4a3b23d21e33dbdaab7990755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5c55c4a3b23d21e33dbdaab7990755">&#9670;&#160;</a></span>setUniform() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">Glsl::Mat4</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>mat4</code> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">matrix</td><td>Value of the mat4 matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a2c673c41e37b17d67e4af1298b679f" name="a4a2c673c41e37b17d67e4af1298b679f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2c673c41e37b17d67e4af1298b679f">&#9670;&#160;</a></span>setUniform() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#adeed356d346d87634b4c197a530e4edf">Glsl::Vec2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>vec2</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the vec2 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad654ad8de6f0c56191fa7b8cea21db2" name="aad654ad8de6f0c56191fa7b8cea21db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad654ad8de6f0c56191fa7b8cea21db2">&#9670;&#160;</a></span>setUniform() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a9bdd0463b7cb5316244a082007bd50f0">Glsl::Vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>vec3</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the vec3 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1aee8343800680fd62e1f3d43c24bf" name="abc1aee8343800680fd62e1f3d43c24bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1aee8343800680fd62e1f3d43c24bf">&#9670;&#160;</a></span>setUniform() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">Glsl::Vec4</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>vec4</code> uniform. </p>
<p>This overload can also be called with <a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color</a> objects that are converted to <a class="el" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83" title="4D float vector (vec4 in GLSL)">sf::Glsl::Vec4</a>.</p>
<p>It is important to note that the components of the color are normalized before being passed to the shader. Therefore, they are converted from range [0 .. 255] to range [0 .. 1]. For example, a <a class="el" href="classsf_1_1Color.html" title="Utility class for manipulating RGBA colors.">sf::Color(255, 127, 0, 255)</a> will be transformed to a vec4(1.0, 0.5, 0.0, 1.0) in the shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vector</td><td>Value of the vec4 vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7806a29ffbd0ee9251256a9e7265d479" name="a7806a29ffbd0ee9251256a9e7265d479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7806a29ffbd0ee9251256a9e7265d479">&#9670;&#160;</a></span>setUniform() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>texture</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a texture as <code>sampler2D</code> uniform. </p>
<p><em>name</em> is the name of the variable to change in the shader. The corresponding parameter in the shader must be a 2D texture (<code>sampler2D</code> GLSL type).</p>
<p>Example: </p><div class="fragment"><div class="line">uniform sampler2D the_texture; <span class="comment">// this is the variable in the shader</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><a class="code hl_class" href="classsf_1_1Texture.html">sf::Texture</a> texture;</div>
<div class="line">...</div>
<div class="line">shader.setUniform(<span class="stringliteral">&quot;the_texture&quot;</span>, texture);</div>
<div class="ttc" id="aclasssf_1_1Texture_html"><div class="ttname"><a href="classsf_1_1Texture.html">sf::Texture</a></div><div class="ttdoc">Image living on the graphics card that can be used for drawing.</div><div class="ttdef"><b>Definition</b> <a href="Texture_8hpp_source.html#l00048">Texture.hpp:49</a></div></div>
</div><!-- fragment --><p> It is important to note that <em>texture</em> must remain alive as long as the shader uses it, no copy is made internally.</p>
<p>To use the texture of the object being drawn, which cannot be known in advance, you can pass the special value <a class="el" href="#ac84c7953eec2e19358ea6e2cc5385b8d" title="Represents the texture of the object being drawn.">sf::Shader::CurrentTexture</a>: </p><div class="fragment"><div class="line">shader.setUniform(<span class="stringliteral">&quot;the_texture&quot;</span>, <a class="code hl_variable" href="#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>).</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the texture in the shader </td></tr>
    <tr><td class="paramname">texture</td><td><a class="el" href="classsf_1_1Texture.html" title="Image living on the graphics card that can be used for drawing.">Texture</a> to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab18f531e1f726b88fec1cf5a1e6af26d" name="ab18f531e1f726b88fec1cf5a1e6af26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18f531e1f726b88fec1cf5a1e6af26d">&#9670;&#160;</a></span>setUniform() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify current texture as <code>sampler2D</code> uniform. </p>
<p>This overload maps a shader texture variable to the texture of the object being drawn, which cannot be known in advance. The second argument must be <a class="el" href="#ac84c7953eec2e19358ea6e2cc5385b8d" title="Represents the texture of the object being drawn.">sf::Shader::CurrentTexture</a>. The corresponding parameter in the shader must be a 2D texture (<code>sampler2D</code> GLSL type).</p>
<p>Example: </p><div class="fragment"><div class="line">uniform sampler2D current; <span class="comment">// this is the variable in the shader</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">shader.setUniform(<span class="stringliteral">&quot;current&quot;</span>, <a class="code hl_variable" href="#ac84c7953eec2e19358ea6e2cc5385b8d">sf::Shader::CurrentTexture</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the texture in the shader </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf78e3bea1e9b0bab850b6b0a0de29c7" name="abf78e3bea1e9b0bab850b6b0a0de29c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf78e3bea1e9b0bab850b6b0a0de29c7">&#9670;&#160;</a></span>setUniform() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>float</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">x</td><td>Value of the float scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4fc8b4c18e6b653952bce5c8c81e4a0" name="ae4fc8b4c18e6b653952bce5c8c81e4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fc8b4c18e6b653952bce5c8c81e4a0">&#9670;&#160;</a></span>setUniform() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify value for <code>int</code> uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">x</td><td>Value of the int scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a731d3b9953c50fe7d3fb03340b97deff" name="a731d3b9953c50fe7d3fb03340b97deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731d3b9953c50fe7d3fb03340b97deff">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>scalarArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>float</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">scalarArray</td><td>pointer to array of <code>float</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69587701d347ba21d506197d0fb9f842" name="a69587701d347ba21d506197d0fb9f842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69587701d347ba21d506197d0fb9f842">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a9e984ebdc1cebc693a12f01a32b2d28d">Glsl::Mat3</a> *</td>          <td class="paramname"><span class="paramname"><em>matrixArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>mat3</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">matrixArray</td><td>pointer to array of <code>mat3</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066b0ba02e1c1bddc9e2571eca1156ab" name="a066b0ba02e1c1bddc9e2571eca1156ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066b0ba02e1c1bddc9e2571eca1156ab">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a769de806596348a8e56ed6506c688271">Glsl::Mat4</a> *</td>          <td class="paramname"><span class="paramname"><em>matrixArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>mat4</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">matrixArray</td><td>pointer to array of <code>mat4</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2e2eab45d9a091f3720c0879a5bb026" name="ab2e2eab45d9a091f3720c0879a5bb026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e2eab45d9a091f3720c0879a5bb026">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#adeed356d346d87634b4c197a530e4edf">Glsl::Vec2</a> *</td>          <td class="paramname"><span class="paramname"><em>vectorArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>vec2</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vectorArray</td><td>pointer to array of <code>vec2</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeae884292fed977bbea5039818f208e7" name="aeae884292fed977bbea5039818f208e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae884292fed977bbea5039818f208e7">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a9bdd0463b7cb5316244a082007bd50f0">Glsl::Vec3</a> *</td>          <td class="paramname"><span class="paramname"><em>vectorArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>vec3</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vectorArray</td><td>pointer to array of <code>vec3</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa89ac1ea7918c9b1c2232df59affb7fa" name="aa89ac1ea7918c9b1c2232df59affb7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89ac1ea7918c9b1c2232df59affb7fa">&#9670;&#160;</a></span>setUniformArray() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::Shader::setUniformArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesf_1_1Glsl.html#a7c67253548c58adb77cb14f847f18f83">Glsl::Vec4</a> *</td>          <td class="paramname"><span class="paramname"><em>vectorArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify values for <code>vec4</code>[] array uniform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the uniform variable in GLSL </td></tr>
    <tr><td class="paramname">vectorArray</td><td>pointer to array of <code>vec4</code> values </td></tr>
    <tr><td class="paramname">length</td><td>Number of elements in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac84c7953eec2e19358ea6e2cc5385b8d" name="ac84c7953eec2e19358ea6e2cc5385b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84c7953eec2e19358ea6e2cc5385b8d">&#9670;&#160;</a></span>CurrentTexture</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsf_1_1Shader_1_1CurrentTextureType.html">CurrentTextureType</a> sf::Shader::CurrentTexture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the texture of the object being drawn. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab18f531e1f726b88fec1cf5a1e6af26d" title="Specify current texture as sampler2D uniform.">setUniform(const std::string&amp;, CurrentTextureType)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Shader_8hpp_source.html#l00082">82</a> of file <a class="el" href="Shader_8hpp_source.html">Shader.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Shader_8hpp_source.html">Shader.hpp</a></li>
</ul>
</div><!-- contents -->
                        </div>
                    </div>
                </div>
                <button type="button" class="md-top md-icon" data-md-component="top" hidden>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
                    Back to top
                </button>
            </main>
            <footer class="md-footer">
                <nav class="md-footer__inner md-grid" aria-label="Footer" hidden>
                    <a href="/learn/" class="md-footer__link md-footer__link--next" aria-label="Next: Learn">
                        <div class="md-footer__title">
                            <span class="md-footer__direction"> Next </span>
                            <div class="md-ellipsis">Learn</div>
                        </div>
                        <div class="md-footer__button md-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z" /></svg>
                        </div>
                    </a>
                </nav>
                <div class="md-footer-meta md-typeset">
                    <div class="md-footer-meta__inner md-grid">
                        <div class="md-copyright">
                            <div class="md-copyright__highlight">Copyright &copy; <a href="mailto:laurent@sfml-dev.org">Laurent Gomila</a></div>
                        </div>
                        <div class="md-social">
                            <a href="https://fosstodon.org/@sfml" target="_blank" rel="noopener me" title="SFML on Fosstodon" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"
                                    />
                                </svg>
                            </a>
                            <a href="https://twitter.com/sfmldev" target="_blank" rel="noopener" title="SFML on Twitter" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"
                                    />
                                </svg>
                            </a>
                            <a href="https://discord.gg/nr4X7Fh" target="_blank" rel="noopener" title="SFML&#39;s Discord Server" class="md-social__link">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512">
                                    <!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.-->
                                    <path
                                        d="M524.531 69.836a1.5 1.5 0 0 0-.764-.7A485.065 485.065 0 0 0 404.081 32.03a1.816 1.816 0 0 0-1.923.91 337.461 337.461 0 0 0-14.9 30.6 447.848 447.848 0 0 0-134.426 0 309.541 309.541 0 0 0-15.135-30.6 1.89 1.89 0 0 0-1.924-.91 483.689 483.689 0 0 0-119.688 37.107 1.712 1.712 0 0 0-.788.676C39.068 183.651 18.186 294.69 28.43 404.354a2.016 2.016 0 0 0 .765 1.375 487.666 487.666 0 0 0 146.825 74.189 1.9 1.9 0 0 0 2.063-.676A348.2 348.2 0 0 0 208.12 430.4a1.86 1.86 0 0 0-1.019-2.588 321.173 321.173 0 0 1-45.868-21.853 1.885 1.885 0 0 1-.185-3.126 251.047 251.047 0 0 0 9.109-7.137 1.819 1.819 0 0 1 1.9-.256c96.229 43.917 200.41 43.917 295.5 0a1.812 1.812 0 0 1 1.924.233 234.533 234.533 0 0 0 9.132 7.16 1.884 1.884 0 0 1-.162 3.126 301.407 301.407 0 0 1-45.89 21.83 1.875 1.875 0 0 0-1 2.611 391.055 391.055 0 0 0 30.014 48.815 1.864 1.864 0 0 0 2.063.7A486.048 486.048 0 0 0 610.7 405.729a1.882 1.882 0 0 0 .765-1.352c12.264-126.783-20.532-236.912-86.934-334.541ZM222.491 337.58c-28.972 0-52.844-26.587-52.844-59.239s23.409-59.241 52.844-59.241c29.665 0 53.306 26.82 52.843 59.239 0 32.654-23.41 59.241-52.843 59.241Zm195.38 0c-28.971 0-52.843-26.587-52.843-59.239s23.409-59.241 52.843-59.241c29.667 0 53.307 26.82 52.844 59.239 0 32.654-23.177 59.241-52.844 59.241Z"
                                    />
                                </svg>
                            </a>
                        </div>
                    </div>
                </div>
            </footer>
        </div>
        <div class="md-dialog" data-md-component="dialog">
            <div class="md-dialog__inner md-typeset"></div>
        </div>
        <script id="__config" type="application/json">
            {
                "base": ".",
                "features": ["content.code.copy", "navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.prune", "navigation.path", "navigation.indexes", "navigation.top", "navigation.footer", "toc.follow", "search.suggest"],
                "search": "/assets/javascripts/workers/search.b8dbb3d2.min.js",
                "translations": {
                    "clipboard.copied": "Copied to clipboard",
                    "clipboard.copy": "Copy to clipboard",
                    "search.result.more.one": "1 more on this page",
                    "search.result.more.other": "# more on this page",
                    "search.result.none": "No matching documents",
                    "search.result.one": "1 matching document",
                    "search.result.other": "# matching documents",
                    "search.result.placeholder": "Type to start searching",
                    "search.result.term.missing": "Missing",
                    "select.version": "Select version"
                }
            }
        </script>
        <script src="/assets/javascripts/bundle.fe8b6f2b.min.js"></script>
    </body>
</html>
